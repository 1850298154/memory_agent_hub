---
created: 2025-10-24T15:54:11 (UTC +08:00)
tags: [社区检测算法]
source: https://blog.csdn.net/liu_673/article/details/126607745
author: 微信公众号
---

# NLP--社区检测算法(Community Detection)总结【原理】-CSDN博客

> ## Excerpt
> 文章浏览阅读2.4w次，点赞74次，收藏220次。本文介绍了社区检测的基本概念，探讨了社区与社区检测算法的关系，并详细解析了几种常用的社区检测算法，包括鲁汶算法、莱顿算法、标签传播算法等。

---
## **文章目录**

[文章目录](https://blog.csdn.net/liu_673/article/details/126607745#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95)

[社区检测(Community Detection)](https://blog.csdn.net/liu_673/article/details/126607745#%E7%A4%BE%E5%8C%BA%E6%A3%80%E6%B5%8B%28Community%20Detection%29)

[社区](https://blog.csdn.net/liu_673/article/details/126607745#%E7%A4%BE%E5%8C%BA)

[社区检测](https://blog.csdn.net/liu_673/article/details/126607745#%E7%A4%BE%E5%8C%BA%E6%A3%80%E6%B5%8B)

[社区检测与聚类的对比分析](https://blog.csdn.net/liu_673/article/details/126607745#%E7%A4%BE%E5%8C%BA%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%81%9A%E7%B1%BB%E7%9A%84%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90)

[鲁汶算法(Louvain )](https://blog.csdn.net/liu_673/article/details/126607745#%E9%B2%81%E6%B1%B6%E7%AE%97%E6%B3%95%28Louvain%20%29)

[莱顿社区检测(Leiden)](https://blog.csdn.net/liu_673/article/details/126607745#%E8%8E%B1%E9%A1%BF%E7%A4%BE%E5%8C%BA%E6%A3%80%E6%B5%8B%28Leiden%29)

[标签传播算法(Label propagation algorithm)](https://blog.csdn.net/liu_673/article/details/126607745#%E6%A0%87%E7%AD%BE%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95%28Label%20propagation%20algorithm%29)

[强连接组件(Strongly Connected Components)](https://blog.csdn.net/liu_673/article/details/126607745#%E5%BC%BA%E8%BF%9E%E6%8E%A5%E7%BB%84%E4%BB%B6%28Strongly%20Connected%20Components%29)

[弱连接组件(Weakly Connected Components)](https://blog.csdn.net/liu_673/article/details/126607745#%E5%BC%B1%E8%BF%9E%E6%8E%A5%E7%BB%84%E4%BB%B6%28Weakly%20Connected%20Components%29)

[三角形计数(Triangle Count)](https://blog.csdn.net/liu_673/article/details/126607745#%E4%B8%89%E8%A7%92%E5%BD%A2%E8%AE%A1%E6%95%B0%28Triangle%20Count%29)

[局部聚类系数(Local Clustering Coefficient)](https://blog.csdn.net/liu_673/article/details/126607745#%E5%B1%80%E9%83%A8%E8%81%9A%E7%B1%BB%E7%B3%BB%E6%95%B0%28Local%20Clustering%20Coefficient%29)

[其他](https://blog.csdn.net/liu_673/article/details/126607745#%E5%85%B6%E4%BB%96)

[总结](https://blog.csdn.net/liu_673/article/details/126607745#%E6%80%BB%E7%BB%93)

[参考链接](https://blog.csdn.net/liu_673/article/details/126607745#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5)

___

## 社区检测(Community Detection)

社区检测（Community Detection）又被称为是社区发现。它是用来揭示网络聚集行为的一种技术。

社区检测算法用于评估节点组如何[聚类](https://so.csdn.net/so/search?q=%E8%81%9A%E7%B1%BB&spm=1001.2101.3001.7020)或分区，以及它们增强或分离的趋势。

### 社区

**社区是许多网络的属性，其中一个特定的网络可能有多个社区，因此社区内的节点是密集连接的。** **多个社区中的节点可以重叠。**例如日常中的微信、QQ、抖音，我们每天可能会与自己的朋友、同事、家人和生活中其他一些重要的人进行大量互动。它们在我们的社交网络中形成了一个非常密集的社区。

就图而言，社区可以定义为节点的子集，这些节点彼此紧密连接，而与同一图中其他社区中的节点松散连接。（**网络节点在社区内紧密连接成紧密的组，而社区之间则松散连接**。）

对于日常微信、QQ或 抖音 等社交媒体平台，我们试图在这些平台上与其他人联系。最终，一段时间后，我们最终与属于不同社交圈的人建立了联系。这些社交圈可以是一群亲戚、同学、同事等。这些社交圈也就是社区！

**每个社区是一个子图，包含顶点和边。**

**![e9fa691cd41143ebbfb05041435f6bb9.jpeg](NLP--%E7%A4%BE%E5%8C%BA%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95(Community%20Detection)%E6%80%BB%E7%BB%93%E3%80%90%E5%8E%9F%E7%90%86%E3%80%91-CSDN%E5%8D%9A%E5%AE%A2/86a45ed989c4fc24aecaee816825d4a5.jpeg)**

### 社区检测

社区检测（community detection）又被称为是社区发现，它是用来揭示网络聚集行为的一种技术。社区检测实际就是一种网络聚类的方法，这里的“社区”，我们可以将其理解为一类具有相同特性的节点的集合。

![a63da9278fc1448984bd3739092912ba.png](NLP--%E7%A4%BE%E5%8C%BA%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95(Community%20Detection)%E6%80%BB%E7%BB%93%E3%80%90%E5%8E%9F%E7%90%86%E3%80%91-CSDN%E5%8D%9A%E5%AE%A2/194e30ec2f85cad3c98ddbe46a418cf9.png)

社区检测算法的一个关键作用在于**可用于从网络中提取有用的信息**。 社区检测面临的最大挑战是**社区结构没有普遍定义**（与和聚类类似，没标签，无法直接评价效果的好坏）。

**为什么要社区检测？**

1.  在分析不同的网络时，发现其中的社区可能很重要。
    
2.  社区检测技术对于社交媒体算法很有用，可以发现具有共同兴趣的人并保持他们紧密联系。
    
3.  社区检测可用于机器学习中，以检测具有相似属性的组并出于各种原因提取组。例如，该技术可用于发现社交网络或股票市场中的操纵群体。
    

### 社区检测与聚类的对比分析

1.  聚类是一种机器学习技术，其中相似的数据点根据它们的属性被分组到同一个簇中。尽管聚类可以应用于网络，但它是无监督机器学习中一个更广泛的领域，可以处理多种属性类型。聚类算法倾向于将**单个外围节点与其应属于的社区**分开。
2.  社区检测是**专门为网络分析量身定制的，网络分析**依赖于**称为边的单一属性类型**。

社区检测类似于聚类，但是，聚类和社区检测技术都可以应用于许多网络分析问题，并且可能会根据领域产生不同的优缺点。

| 术语 | 定义 |
| --- | --- |
| **模块化** | 
是对网络或图结构的**度量**，它衡量网络划分为模块（也称为组、集群或社区）的强度。

  
高度模块化的网络在模块内的节点之间具有密集的连接，但在不同模块中的节点之间具有稀疏的连接。模块化通常用于检测网络中社区结构的优化方法。然而，已经表明模块化受到分辨率限制，因此无法检测到小型社区。包括动物大脑在内的生物网络表现出高度的模块化。

  
模块化是落在给定组内的边缘的分数减去边缘随机分布的预期分数。未加权和无向图的模块化值在范围内\[-0.5,1\]（**模块化是介于 -0.5（非模块化聚类）和 1（完全模块化聚类）之间的尺度值，用于衡量社区内部边相对于社区外部边的相对密度**）。

如果组内边缘的数量超过基于机会预期的数量，则为正。对于给定的网络顶点划分为一些模块，模块性反映了模块内边缘的集中度，与所有节点之间的随机分布的链接相比，无论模块如何。

 |

在给定的网络中可以有任意数量的社区，并且它们的大小可以不同。这些特征使得社区的检测过程非常困难。然而，在社区检测领域提出了许多不同的技术、算法，由上面的_社区检测与聚类的对比分析_可知，社区检测算法若细细研究，可纳入的算法较多。

针对图算法（即图谱中，我们可用到的一些算法）进行整合，接下来介绍几种图算法中常用的社区检测算法。

___

##  

## 鲁汶算法(Louvain )

鲁汶方法是一种检测大型网络中社区的算法。它最大化了每个社区的模块化分数，其中模块化量化了分配给社区的节点的质量。这意味着评估社区中节点的密集程度，以及它们在随机网络中的连接程度。

Louvain 算法是一种**分层聚类算法**，它以递归方式将社区合并到单个节点中，并在压缩图上执行模块化聚类。（_这意味着在每个群集步骤之后，属于同一群集的所有节点都将减少到单个节点。同一集群节点之间的关系成为自有关系，与其他集群节点的关系连接到集群代表。然后，此精简图用于运行下一级别的聚类分析。重复该过程，直到群集稳定。_）

在社区检测的Louvain方法中，首先通过在所有节点上局部优化模块化来找到小社区，然后将每个小社区分组为一个节点，并重复第一步。即为**迭代重复两个阶段**：

1.  节点的局部移动
    
2.  网络聚合
    

![c64bc4e621144c598e317e8668db7713.jpeg](NLP--%E7%A4%BE%E5%8C%BA%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95(Community%20Detection)%E6%80%BB%E7%BB%93%E3%80%90%E5%8E%9F%E7%90%86%E3%80%91-CSDN%E5%8D%9A%E5%AE%A2/475680ab78dfa73f9d57e190c7611a0f.jpeg)

该算法从 N 个节点的加权网络开始。  
在第一阶段，算法为网络的每个节点分配一个不同的社区。然后对于每个节点，它考虑邻居并评估模块化增益通过从当前社区中删除特定节点并放置在邻居的社区中。如果增益为正且最大化，则该节点将被放置在邻居的社区中。如果没有正收益，该节点将留在同一个社区中。这个过程被重复应用到所有节点，直到没有进一步的改进。**当获得局部最大值时**，Louvain 算法的第一阶段停止。在第二阶段，该算法将在第一阶段找到的社区作为节点来构建一个新的网络。一旦第二阶段完成，算法会将第一阶段重新应用于生成的网络。重复这些步骤，直到网络没有变化并且获得最大的模块化。

Louvain社区检测算法在此过程中**发现社区的社区。**由于易于实现以及算法的速度，它非常受欢迎。然而，该算法的一个主要**限制是在主存储器中使用网络存储**。

## 莱顿社区检测(Leiden)

莱顿算法是一种用于检测大型网络中的社区的算法。该算法将节点分离成不相交的社区，从而最大化每个社区的模块化得分。模块化量化了将节点分配给社区的质量，即社区中节点的密集连接程度，与它们在随机网络中的连接程度相比。

Leiden算法是一种分层聚类算法，它通过贪婪地优化模块化和在压缩图中重复的过程，递归地将社区合并到单个节点中。它修改了鲁汶算法以解决其一些缺点，即鲁汶发现的一些社区联系不紧密的情况。这是通过定期将社区随机分解为较小的连接良好的社区来实现的。

莱顿算法的三个阶段是，

1.  节点的局部移动
    
2.  分区的细化
    
3.  基于细化分区的网络聚合
    

在细化阶段，算法试图从第一阶段提出的分区中识别出细化的分区。**第一阶段提出的社区可能在第二阶段进一步分裂成多个分区**。细化阶段不遵循贪心方法，并且可能将节点与随机选择的社区合并，从而增加质量函数。这种**随机性允许更广泛地发现分区空间**。同样在第一阶段，莱顿对鲁汶采取了不同的方法。**与第一次访问所有节点完成后访问网络中的所有节点不同，Leiden 只访问那些邻域发生变化的节点**。

![494259143ead4a12b61570fe0dbb6704.png](NLP--%E7%A4%BE%E5%8C%BA%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95(Community%20Detection)%E6%80%BB%E7%BB%93%E3%80%90%E5%8E%9F%E7%90%86%E3%80%91-CSDN%E5%8D%9A%E5%AE%A2/45d47db8afbd077e1c75df19cc81e196.png)

## 标签传播算法(Label propagation algorithm)

标签传播算法 （LPA） 是一种用于在图形中查找社区的快速算法。它仅使用网络结构作为其指导来检测这些社区，并且不需要预定义的目标函数或有关社区的先验信息。

LPA的工作原理是在整个网络中**传播标签**，并基于这种标签传播过程形成社区。

**标签传播**是一种**半监督机器学习算法**，将标签分配给以前未标记的数据点。在算法开始时，数据点的（通常很小的）子集具有标签（或分类）。这些标签在整个算法过程中传播到未标记的点。

**优缺点：**

-   优点：与其他算法相比标签传播在其运行时间和网络结构所需的先验信息量方面具有优势（不需要事先知道参数）。
-   缺点：它不会产生唯一的解决方案，而是许多解决方案的集合。

在初始条件下，节点带有一个标签，表示它们所属的社区。社区中的成员身份会根据相邻节点拥有的标签而变化。此更改受节点一度内的最大标签数的限制。每个节点都用一个唯一的标签初始化，然后标签在网络中扩散。因此，密集连接的组很快就达到了一个共同的标签。当在整个网络中创建许多这样的密集（共识）组时，它们会继续向外扩展，直到不能这样做。

**该算法的工作原理如下：**

-   每个节点都使用唯一的社区标签（标识符）进行初始化。
    
-   这些标签通过网络传播。
    
-   在每次迭代传播时，每个节点都会将其标签更新为其邻居的最大数量所属的标签。关系是任意但确定地断开的。
    
-   当每个节点都具有其邻居的多数标签时，LPA 达到收敛状态。
    
-   如果实现了收敛或用户定义的最大迭代次数，则 LPA 将停止。
    

随着标签的传播，密集连接的节点组很快就会就唯一标签达成共识。在传播结束时，只有少数标签将保留 - 大多数将消失。**在收敛时具有相同社区标签的节点称为属于同一社区**。

LPA的一个有趣的功能是，可以为节点分配初步标签，以缩小生成的解决方案的范围。这意味着它可以用作**半监督的方式**来寻找我们亲自挑选一些初始社区的社区。

## 强连接组件(Strongly Connected Components)

强连接组件 （SCC） 算法在有向图中查找**最大连接节点集**。如果集合内每对节点之间都有一条有向路径，则该集合被视为强连接组件。它通常在图形分析过程的早期使用，以帮助我们了解图形的结构。

在有向图的数学理论中，如果每个顶点都可以从其他每个顶点到达，则称该图为**强连接**图。**任意有向图的强连接组件形成一个子图的分区，这些子图本身是强连接的。**

对顶点之间在每个方向上都有一条路径，则称为**强连接图。**即，从该对中的第一个顶点到第二个顶点存在一条路径，从第二个顶点到第一个顶点存在另一条路径。

![d2b6630e4d264bb183d405fb6dd9ad05.png](NLP--%E7%A4%BE%E5%8C%BA%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95(Community%20Detection)%E6%80%BB%E7%BB%93%E3%80%90%E5%8E%9F%E7%90%86%E3%80%91-CSDN%E5%8D%9A%E5%AE%A2/39e49df56a1055cc7450107090715374.png)

黄色有向无环图是蓝色有向图的浓缩。它是通过将蓝色图的每个强连通分量收缩为单个黄色顶点而形成的。

**用例**

-   在对强大跨国公司的分析中，SCC可用于找出每个成员直接或间接拥有其他成员股份的一组公司。虽然它有好处，例如降低交易成本和增加信任，但这种类型的结构会削弱市场竞争。
    
-   在测量多跳无线网络中的路由性能时，SCC 可用于计算不同网络配置的连通性。
    
-   强连接组件算法可以用作许多图形算法的第一步，这些算法仅适用于强连接图形。在社交网络中，一群人通常有很强的联系（例如，一个班级或任何其他常见地方的学生）。这些组中的许多人通常喜欢一些常见的页面，或者玩普通的游戏。SCC算法可用于查找此类组，并向组中尚未喜欢这些页面或游戏的用户推荐常用页面或游戏。
    

## 弱连接组件(Weakly Connected Components)

弱连接组件（WCC） 算法在无向图中查找连接的节点集，其中同一集中的所有节点形成一个连接的组件。WCC通常在分析的早期用于理解图形的结构。使用 WCC 了解图形结构可以在已识别的集群上独立运行其他算法。**作为有向图的预处理步骤，它有助于快速识别断开连接的组**。

给定一个有向图，弱连通分量 (WCC) 是原始图的子图，其中所有顶点通过某种路径相互连接，忽略边的方向。在无向图的情况下，**弱连接组件也是强连接组件**。该模块还包括许多对 WCC 输出进行操作的辅助函数。

![14413a5f3e14476581d49e10da046b51.jpeg](NLP--%E7%A4%BE%E5%8C%BA%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95(Community%20Detection)%E6%80%BB%E7%BB%93%E3%80%90%E5%8E%9F%E7%90%86%E3%80%91-CSDN%E5%8D%9A%E5%AE%A2/1eb437448d171649a2e4df2400c53bbb.jpeg)

在上面的有向图中，有两个弱连通分量：  
\[0, 1, 2, 3\]  
\[4, 5\]

## 三角形计数(Triangle Count)

三角形计数算法计算图形中每个节点的三角形数。三角形是一组三个节点，其中每个节点与其他两个节点有关系。在图论术语中，这有时被称为3集团。

三角形计数在社交网络分析中越来越受欢迎，它**用于检测社区并测量这些社区的凝聚力**。它还可用于确定图形的稳定性，并且通常用作网络索引计算的一部分，例如[聚类系数](https://so.csdn.net/so/search?q=%E8%81%9A%E7%B1%BB%E7%B3%BB%E6%95%B0&spm=1001.2101.3001.7020)。**三角形计数算法还用于计算_局部聚类系数_。**

**Triangle Count算法如下：**

-   **计算每个结点的邻结点。**
    
-   **统计对每条边计算交集，并找出交集中id大于前两个结点id的结点。**
    
-   **对每个结点统计Triangle总数，注意只统计符合计算方向的Triangle Count。**
    

注意：计算三角形时，要有计算方向（如，起始结点id<中间结点id<目的结点id）。

假设结点A和结点B是邻居。结点A的邻结点集合是{B，C，D，E}，结点B的邻结点集合是{A，C，E，F，G}，而它们的交集是{C，E}。交集中的结点是结点A和结点B的共同邻结点，所以有{A，B，C}和{A，B，E}两个三角形。

## 局部聚类系数(Local [Clustering](https://so.csdn.net/so/search?q=Clustering&spm=1001.2101.3001.7020) Coefficient)

在图论中，聚类系数是图中节点倾向于**聚集在一起的程度的度量**。有证据表明，在大多数现实世界的网络中，尤其是社交网络中，节点往往会创建紧密联系的群体，其特点是关系密度相对较高。**_这种可能性往往大于两个节点之间随机建立的平局的平均概率。_**

聚类系数存在两个版本：全局和本地（局部）。

**全局版本旨在给出网络中集群的整体指示，而本地版本则给出单个节点的嵌入性指示。**

局部聚类系数算法计算图形中每个节点的局部聚类系数。节点 _n_ 的局部聚类系数 C _n_ 描述了 _n_ 的邻居也连接的可能性。要计算_Cn_，我们使用节点是_Tn_的一部分的三角形数，以及节点_dn_的度数。计算局部聚类系数的公式如下：

![66dc1315f94246558eadb751e67ad1ad.jpeg](NLP--%E7%A4%BE%E5%8C%BA%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95(Community%20Detection)%E6%80%BB%E7%BB%93%E3%80%90%E5%8E%9F%E7%90%86%E3%80%91-CSDN%E5%8D%9A%E5%AE%A2/699196cfd7f093aef19aa8fd13928e2b.jpeg)

正如我们所看到的，计算局部聚类系数需要三角形计数。为此，使用了三角形计数算法。

此外，该算法可以计算**整个图形_的平均聚类系数_。**这是所有局部聚类系数的归一化和。

___

##  

## 其他

对于整个社区检测算法，这位大佬（[马东什么](https://blog.csdn.net/liu_673/article/details/%5B%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95%E7%BB%BC%E8%BF%B0%20-%20%E7%9F%A5%E4%B9%8E%20%28zhihu.com%29%5D%28https%3A//zhuanlan.zhihu.com/p/141401358%29)）总结整理的非常全面，而且将社区发现算法进行分类整合，分为**五类**：

传统的社区检测技术、基于分裂的社区检测技术、基于模块化优化的社区检测技术、重叠社区检测技术、动态社区检测算法。

以下两张图，从不同的角度对社区检测算法进行了归纳。

![c8909fc337db494f96b835d723293707.png](NLP--%E7%A4%BE%E5%8C%BA%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95(Community%20Detection)%E6%80%BB%E7%BB%93%E3%80%90%E5%8E%9F%E7%90%86%E3%80%91-CSDN%E5%8D%9A%E5%AE%A2/43405bf8c3627fa9c63919a407038eba.png)

 ![ff2f0e6e67ba4a4f80a141eb6cb7536a.png](NLP--%E7%A4%BE%E5%8C%BA%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95(Community%20Detection)%E6%80%BB%E7%BB%93%E3%80%90%E5%8E%9F%E7%90%86%E3%80%91-CSDN%E5%8D%9A%E5%AE%A2/1033f4b77074e50ba6c0ffdc116450d7.png)

___

## 总结

本文对社区发现算法，从定义、原理进行了整理归纳，重点是从图算法的角度对几种社区检测算法进行了阐述。社区检测算法太多，仍需继续努力！！！

以上是我个人在学习过程中的记录所学，希望对正在一起学习的小伙伴有所帮助！！！

___

##  

## 参考链接

[社区发现算法\_百度百科 (baidu.com)](https://baike.baidu.com/item/%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95/19460396?fr=aladdin "社区发现算法_百度百科 (baidu.com)")

[社区检测算法（Community Detection） - 简书 (jianshu.com)](https://www.jianshu.com/p/0c1ebbd3a246 "社区检测算法（Community Detection） - 简书 (jianshu.com)")

[社区发现算法综述 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/141401358 "社区发现算法综述 - 知乎 (zhihu.com)")

[(10条消息) 论文翻译 - 深度学习社区发现综述 A Comprehensive Survey on Community Detection with Deep Learning\_u010313476的博客-CSDN博客](https://blog.csdn.net/u010313476/article/details/118718904 "(10条消息) 论文翻译 - 深度学习社区发现综述 A Comprehensive Survey on Community Detection with Deep Learning_u010313476的博客-CSDN博客")

[(3条消息) 社区发现（一）--算法综述Eason.wxd的博客-CSDN博客社群发现算法](https://blog.csdn.net/App_12062011/article/details/91352358 "(3条消息) 社区发现（一）--算法综述Eason.wxd的博客-CSDN博客社群发现算法")

[社区发现算法 - Fast Unfolding（Louvian）算法初探 - 郑瀚Andrew.Hann - 博客园 (cnblogs.com)](https://www.cnblogs.com/LittleHann/p/9078909.html#_lab2_0_4 "社区发现算法 - Fast Unfolding（Louvian）算法初探 - 郑瀚Andrew.Hann - 博客园 (cnblogs.com)")

---
created: 2025-10-25T18:01:18 (UTC +08:00)
tags: [算法,大数据风控,社区检测]
source: https://zhuanlan.zhihu.com/p/556291759
author: 关于作者小伍哥聊风控风控算法、风控策略，反欺诈，异常检测，复杂网络挖掘、风控转行回答68文章106关注者12,323关注他发私信
---

# (70 封私信 / 83 条消息) 万物皆网络，万字长文详解社区发现算法Louvain - 知乎

> ## Excerpt
> 大家好，我是小伍哥，好久没更新，今天发一篇社区发现（community detection）的文章，文章靠几十篇文章拼拼凑凑而成，也就不标原创了，不过我也写了很多观点进去，还是非常好的参考学习资料。所谓的社群发现，通…

---
![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-82d0e09564f235a463c5bada3e660d74_1440w.jpg)

大家好，我是小伍哥，好久没更新，今天发一篇社区发现（community detection）的文章，文章靠几十篇文章拼拼凑凑而成，也就不标原创了，不过我也写了很多观点进去，还是非常好的参考学习资料。所谓的社群发现，通俗点，可以叫团伙挖掘，是风控工作中非常核心的算法，我上次也写过一篇LPA的，今天再写一篇Louvain算法相关的，如果你就是想调个包，那直接跳到第八部分就行，如果想认真的了解下，那就从头开始。**注意：**我一直认为，在团伙挖掘的过程中，介质的质量、边的构建思路、以及业务的抽象能力，比什么算法都重要，盲目的在质量不高的数据上，啥算法都没用。

> 一、社区发现概述  
> 1、社区是什么  
> 2、社区发现的目标和意图  
> 3、节点间存在连接的抽象本质 - 逻辑拓朴结构  
> 4、什么时候可以使用[社区发现算法](https://zhida.zhihu.com/search?content_id=211753102&content_type=Article&match_order=1&q=%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95&zhida_source=entity)  
> 5、社区划分的直观思路  
> 二、什么是[模块度](https://zhida.zhihu.com/search?content_id=211753102&content_type=Article&match_order=1&q=%E6%A8%A1%E5%9D%97%E5%BA%A6&zhida_source=entity)
> 
> 三、模块度最大化算法  
> 1、算法流程  
> 2、怎么表示一个随机图
> 
> 四、Louvain 算法  
> 1、不同密度社区对比  
> 2、社区发现效果评估-模块化指数Q  
> 3、社区发现算法-Louvain
> 
> 五、基本概念—权重度  
> 1、节点权重度  
> 2、社区权重度  
> 3、社区内部权重度  
> 4、全图权重度
> 
> 六、基本概念—社区压缩  
> 1、什么是社区压缩？  
> 2、为什么要进行社区压缩
> 
> 七、Louvain算法结果处理
> 
> 八、Louvain算法应用

## **一、社区发现概述**

## 1、社区是什么

在最常见的社交网络中，每个用户相当一个点，用户之间的互相关注、点赞、私信等形成了边，用户以及相互作用关系构成了一个大的关系网络。在这样的网络中，有的用户之间的连接较为紧密，有的用户之间的连接关系较为稀疏。其中连接较为紧密的部分可以被看成一个社区，其内部的节点之间有**较为紧密**的连接，而在两个社区间则相对连接**较为稀疏，**整个整体的结构被称为社团结构，如下图，红色的黑色的点集呈现出社区的结构。

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-9fb83d5a6fe929cfeae5a9687f2c796d_1440w.jpg)

用红色的点和黑色的点对其进行标注，整个网络被划分成了两个部分，其中，这两个部分的内部连接较为紧密，而这两个社区之间的连接则较为稀疏。如何去划分上述的社区便称为社区划分的问题。

## 2、社区发现的目标和意图

社区发现的目标是什么？我们为什么要去做社区发现？。社区发现的目的也很简单，就是在图中找到一些“**潜在的有特定关系的组织**”，也就是**社区(community)**。直观地说，社区发现（community detection）的一般目标是要探测网络中较为紧密的【块cluster】或是【社团community】。这么做的目的和效果有许多，特别是在风控中，很多有目的的团伙，聚集在一起，有明显的社群关系。哪个块是高风险，哪个块是高价值，非常值得挖掘。

我们再看一个例子，词的联想和搭配构成的网络

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-88d428082c02660204d8078832bfe545_1440w.jpg)

我们用不同的颜色对community进行标记，可以看到这种检测得到的结果很有意思。这个网络从词bright开始进行演化，到后面分别形成了4个组：**Colors**,**Light**,**Astronomy**&**Intelligence**。可以说以上这4个词可以较好地概括其所在community的特点（有点聚类的感觉）；另外，community中心的词，比如color, Sun, Smart也有很好的代表性（自动提取摘要）。同时我们注意到，那些处在交叠位置的词呢，比如Bright、light等词，他们是同义项比较多的词。这个图也揭示出了这一层含义。

## 3、节点间存在连接的抽象本质 - 逻辑拓朴结构

**社区的节点间是网络拓朴结构，即节点间是存在拓朴连接结构的，我们不能将其和欧式空间或者P空间中的点向量集合空间混为一谈**。以欧式空间为例，不同的节点向量存在于不同的空间位置中，向量夹角近的点向量彼此距离近，而向量夹角远的向量彼此距离远。但是即使是欧式距离很近的向量点，也不一定就代表这它们之间存在拓朴连接关系，只能说在一定的度量下（例如欧式距离度量），这两个节点很相近。但是在社区结构中，节点之间没有什么空间位置的概念。相对的，节点间存在的是一种**逻辑拓朴结构**，即存在一种**共有关系**。存在共有关系的节点在逻辑上会聚集为一个社区，而社区之前不存在或者存在很弱的共有关系，则呈现分离的逻辑拓朴结构。一定要注意不要用空间结构的概念来试图理解社区结构，不然会陷入理解的困境，并且会限制想象力，社区中的节点只是因为**逻辑上的共有关系而聚集在一起而已**，彼此之间的位置也没有实际意义，而社区族群之间的分离也是表达一种逻辑上的弱共有关系。举一些实际的例子：1） 假如节点代表消费者：节点间的连接代表了它们共同购买了一批书籍，权重代表共同购买的书籍数，链接越紧密，代表社群的爱好越相近。2） 假如节点代表消费者：节点间的连接代表了它们共同领取一批优惠群，权重代表共同领取的优惠券的数量，该社群可能是一个羊毛党社群。3） 假如节点代表商家：节点间的连接代表了它们共同商品标题，权重代表共同标题商品的数量，该社群可能是一个店群商家，不断换点进行欺诈。共同的地点、共同的设备、共同的轨迹、共同的时间、共同的证件等等，都可以作为这种逻辑关系的存在，作为一个网络，我们进行社区挖掘，达到我们的业务目的。

## 4、什么时候可以使用社区发现算法

下面这句话很明确地说明了在什么业务场景下可以使用社区发现算法：我们需要先确定要解决的业务场景中，存在明显的聚集规律，节点（可以是抽象的）之间形成一定的族群结构，而不是呈现无规律的随机分散。同时另一方面，这种聚集的结构是“有意义的”，这里所谓的有意义是指这种聚集本身可以翻译为一定的上层业务场景的表现。但是很多时候，我们业务场景中的数据集之间的共有关系并不是表现的很明显，即节点之间互相都或多或少存在一些共有关系，这样直接进行社区发现效果肯定是不好的。就没必要进行社区发现挖掘。所以一个很重要点是，**我们在进行社区发现之前，一定要进行数据降噪**。理想情况下，降噪后得到的数据集已经是社区完全内聚，社区间完全零连接，这样louvain只要一轮运行就直接得到结果。当然实际场景中不可能有这么好的情况，数据源质量，专家经验的丰富程度等等都会影响降噪的效果，一般情况下，降噪只要能cutoff 90%以上的噪音，louvain就基本能通过几轮的迭代完成整体的社区发现过程。

## 5、社区划分的直观思路

什么样的结构能成为团？一种很直观的想法是，同一团内的节点连接更紧密，即具有更大的density。接下来的问题是，什么样的metrics可以用来描述这种density？Louvian 定义了一个数值上的概念（本质上就是一个目标函数），有了这个目标函数，就可以引出接下来要讨论的 method based on modularity optimization要注意的，社区划分有很多不同的算法，本文讨论的 [Fast Unfolding](https://zhida.zhihu.com/search?content_id=211753102&content_type=Article&match_order=1&q=Fast+Unfolding&zhida_source=entity)（Louvian）只是其中一种，而这种所谓的density密度评估方法也其实其中一种思想，不要固话地认为社区划分就只有这一种方法。

关于社区发现算法可以应用在哪些领域，或者在风控中能用于什么场景，我也一直在思考中，从这个算法的思想上来看，我倾向于认为社区发现算法比较适合发现一种"抽象泛共现模式"，这种共现是一种泛化的共现，它可以是任何形式的共现，例如1）两个用户拥有共同的介质2）两个用户昵称采用共同的起名方式，比如名字加数字，同样的前缀，或者都是四字成语等3）用户拥有相同的行为，比如做过同样的操作，4）用户拥有共同的控制人等5）两个用户发布的内容拥有相似的词频数据6）两个用户拥有相同的运动轨迹... ...社区发现的落地效果，很大程度上，取决于我们对业务拓扑逻辑的抽象水平，以及数据降噪的结果，而不取决于发现的算法。并且不同场景，采用的社区发现算法不一样。在大数据场景下，没有上帝全局视角，并且很多常识在规模面前也不管用，甚至引起认知谬误，因此社区发现算法的结果不可能完美，必须结合业务实际情况进行调节和控制，再应用，不然很难达到预期效果，甚至搞出很多问题。

## **二、什么是模块度**

在各类网络中会存在一些紧密连接的区域，这些区域（节点集）通常有自己的属性，称为**社群或者社团（Community）**，社团内部连接紧密，而社团外部的连接则相对稀疏，即“内紧外松”，根据这个特点，人们设计了算法来探测网络中的社团结构，从而更好地理解网络中蕴含的丰富信息。

![动图]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-e740896fbf2dbcc83541272910602ef5_b.webp)

“社群检测”等同于“给节点分组”，**模块度（Modularity）**是一种常用的衡量节点**分组质量**的标准，模块度越高说明所检测到的社团越符合“内紧外松”的特征，分组质量越好。

基于模块度的概念，网络科学奠基人之一Mark Newman于2004年提出了一种经典的社团检测方法—**模块度最大值法（Modularity maximization）**。它通过考虑网络中所有可能的节点分组，找到使得模块度最大的分组方式。基于模块度的社团检测算法至今仍被广泛使用。

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-6d297d162d7f45345ee9b14f20fc3071_1440w.jpg)

要计算一个网络的模块度，需要构造一个具有相同节点度分布的随机网络作为参照。通俗地来说，模块度的物理含义是：在社团内，实际的边数与随机情况下的边数的差距。如果差距比较大，说明社团内部密集程度显著高于随机情况，社团划分的质量较好。模块度取值范围在\[-0.5,1\]之间。如果节点组中的连边数量超过了随机分配时所得到的期望连边数量，模块度为正数。没有超过，则为负数。

## **三、模块度最大化算法**

模板度最大值法是使用最为广泛的社团检测方法之一，该方法的目标是从所有可能的分组中找到使得模块度最大的分组，由于穷举所有可能的分组十分困难，所以实际的算法都采用近似优化方法。例如，Mark Newman 提出了模块度最大化的贪婪算法**Fast NewMan (FN)**。贪婪算法的原理是找出每个局部最优值，最终将局部最优值整合成整体的近似最优值。

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-ebaa274d9df22281416e8a74ed07b29a_1440w.jpg)

模块度是评估一个社区网络划分好坏的度量方法，它的物理含义是社区内节点的连边数与随机情况下的边数之差，它的取值范围是 \[−1/2,1)，其定义如下：

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-4410e7c2b074625d695a8238061cd6eb_1440w.jpg)

其中， 节点i和节点j之间边的权重，网络不是带权图时，所有边的权重可以看做是1； =∑ 表示所有与节点i相连的边的权重之和（度数）； 表示节点i所属的社区；

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-81968c6835b4f805dafcc1e5827888c3_1440w.jpg)

表示所有边的权重之和（边的数目）。公式中

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-ebdc34e31c9dc32db157571636a774e8_1440w.jpg)

节点j连接到任意一个节点的概率是

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-525fd172e60ab89d3059d02b52663b70_1440w.jpg)

，现在节点i有 的度数，因此在随机情况下节点i与j的边为

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-798bcee20810f2c4b67e5146270387fc_1440w.jpg)

.模块度的公式定义可以作如下简化：

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-aad79662f7bcd7318c9d9eccdca026e9_1440w.jpg)

其中Σ Σin表示社区c内的边的权重之和，Σ Σtot表示与社区c内的节点相连的边的权重之和。上面的公式还可以进一步简化成:

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-68564b5bfb7c95e6d950ac9d3c674bd1_1440w.jpg)

这样模块度也可以理解是社区内部边的权重减去所有与社区节点相连的边的权重和，对无向图更好理解，即社区内部边的度数减去社区内节点的总度数。基于模块度的社区发现算法，都是以最大化模块度Q为目标。

## 1、算法流程

Louvain算法的思想很简单：1）将图中的每个节点看成一个独立的社区，次数社区的数目与节点个数相同；2）对每个节点i，依次尝试把节点i分配到其每个邻居节点所在的社区，计算分配前与分配后的模块度变化Δ ，并记录Δ 最大的那个邻居节点，如果 Δ >0，则把节点i分配Δ 最大的那个邻居节点所在的社区，否则保持不变；3）重复2），直到所有节点的所属社区不再变化；4）对图进行压缩，将所有在同一个社区的节点压缩成一个新节点，社区内节点之间的边的权重转化为新节点的环的权重，社区间的边权重转化为新节点间的边权重；5）重复1）直到整个图的模块度不再发生变化。从流程来看，该算法能够产生层次性的社区结构，其中计算耗时较多的是最底一层的社区划分，节点按社区压缩后，将大大缩小边和节点数目，并且计算节点i分配到其邻居j的时模块度的变化只与节点i、j的社区有关，与其他社区无关，因此计算很快。在论文中，把节点i分配到邻居节点j所在的社区c时模块度变化为：

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-8e56a105b4d0a2af47f7ec0d2e863a21_1440w.jpg)

其中 , 是社区c内节点与节点i的边权重之和，注意对 , 是对应边权重加起来再乘以2，这点在实现时很容易犯错。Δ 分了两部分，前面部分表示把节点i加入到社区c后的模块度，后一部分是节点i作为一个独立社区和社区c的模块度，这里有一个困惑我的地方，虽然我按照这个公式实现的分群算法效果很好，但是我认为Δ 少了把节点i从其原来社区删除这一步，因为后面的划分时，节点i所在的社区可能有多个节点。在实现的时候模块度变化还可以简化，把上面的公式展开，很多项就抵消了，化简之和：

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-d8d2d24adf5b9d68d57c88d0b3bb79db_1440w.jpg)

论文中指出，算法第2）步节点的顺序会对分群结果又一定影响，但分群效果差距不大，只是会影响算法的时间效率，还有论文指出按度数从到的小的顺序处理速度最快，不过我在1K边上的图测试，差距不大。

1）初始时将网络中的每个节点都看成独立的小社团。2）考虑所有相连社团两两合并的情况，计算每种合并带来的模块度的增量。3）基于贪婪原则，选取使模块度增长最大的两个社团，将它们合并成一个社团。4）如此循环迭代。随着迭代的进行，模块度不断变化，其最大值时对应最优社团划分。

后来，Vincent Blondel等人运用模板度最大值法的基本原理，提出了**Louvain算法**，大大降低了算法的时间复杂度。十分适合社会网络等超大规模网络的社团检测。也成为应用最广的算法之一。使用Python的网络科学工具包[NetworkX](https://zhida.zhihu.com/search?content_id=211753102&content_type=Article&match_order=1&q=NetworkX&zhida_source=entity) , 可以轻松调用该算法，实现社团检测。

NetworkX：是Python在复杂网络分析领域的软件包，网络分析的必备神器，谁用谁知道。它功能强大，几乎覆盖复杂网络分析中的所有可计算的概念。小伙伴们只要会使用Python进行基本编程，就可以用起来。

官网地址：[https://networkx.github.io](https://link.zhihu.com/?target=https%3A//networkx.github.io)

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-80f4aa1459cefb3d19752410bd429088_1440w.jpg)

**图4：运用模块度最大值算法检测出的社团。节点为公司，边为公司间职员的流动。蓝色为线上为主的公司、黄色为线下为主的公司、红色为线上线下兼顾的公司。**

## 2、怎么表示一个随机图

一个好的社区一定是内部的连接要比随机连接情况下的连接更紧密。说到随机，那自然需要一个零模型(图模型)，这里选择的是配置模型(configuration model)，为了保证与原图有相同的度分布。类似与在介绍 motifs 时，运用的模型，不同的是，这里允许有重边(multi edge)的 multigraph。

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-01e5b480427ec0d8e70f3d5476b5387c_1440w.jpg)

louvain 算是目前市面上提到的和使用过的最常用的社区发现算法之一了，除此之外就是 [infomap](https://zhida.zhihu.com/search?content_id=211753102&content_type=Article&match_order=1&q=infomap&zhida_source=entity)，这两种。原始论文为：《Fast unfolding of communities in large networks》。所以又被称为Fast unfolding算法。

模块度（Modularity）用来衡量一个社区的划分是否优良。一个好的划分结果其表现形式是：在社区内部的节点相似度较高，而在社区外部节点的相似度较低。模块度的定义由于当时研究的图类型的不同而一直发生变化，

**模块度**是评估一个社区网络划分好坏的度量方法，它的物理含义是社区内节点的连边数与随机情况下的边数之差，它的取值范围是 \[−1/2,1)，其定义如下：

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-5b9f155ed11cc1b93c59b836457438fc_1440w.jpg)

结论：模块度越大，挖掘的社区内部连接越紧密，效果越好。

**对无权图：**模块度社区内部边的度数减去社区内节点的总度数。**对于权重图：**模块度也可以理解是社区内部边的权重减去所有与社区节点相连的边的权重和。既然，模块度是评价社区结构好坏的指标。那么，自然可以通过最大化模块度来识别社区。这就是下面算法的思想。

## 1、不同密度社区对比

这个公式的含义一定要理解清楚才能体会到 louvain 背后的真谛，我们来直观的看看，不同紧密程度的社区长什么样子。

```python
#导入建网络模型包，导入科学绘图包 import networkx as nx import matplotlib.pyplot as plt ''' 随机生成网络 用erdos_renyi_graph(n,p)方法生成一个含有n个节点、 以概率p连接的ER随机图，在本程序中以概率0.8连接20个节点中的每一对节点，完成图形。 ''' for i in range(1,11): rate = i/10 print(rate) G = nx.erdos_renyi_graph(20,rate) nx.draw(G, with_labels=True, pos=nx.kamada_kawai_layout(G), #width=edgewidth, node_size=500, alpha=0.8, node_color="r", edge_color="DeepPink" ) text = 'P={rate} Networks Wu'.format(rate=rate) plt.title(text, fontsize = 20) plt.show()
```

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-781af9ad99f791855c13c36a8a88911d_1440w.jpg)

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-9b0df00d4af65d25fa6ff3e18c808135_1440w.jpg)

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-90e318fd1a5b13141f495427b99c08dd_1440w.jpg)

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-848047f51f1289e4249d58e70ba81a25_1440w.jpg)

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-addc5ce4d8125cee3841f8c1cf4ecc52_1440w.jpg)

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-c1cda663d8ad9d768a1c3a9260bb4e33_1440w.jpg)

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-cceb1e56849f5374386fe7240d3b5e2e_1440w.jpg)

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-f3f7a268bda14311d5361dc358280c71_1440w.jpg)

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-b99c7a041beefd2c357da7c5d1d2b939_1440w.jpg)

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-668ef41c1b8e59c07be27f26dbdca95e_1440w.jpg)

## 2、社区发现效果评估-模块化指数Q

光说思路是没有意义的，在数学上应该如何定义社区发现效果的好坏呢？结论就是**直接和随机模型比较就好啦！**你问我什么叫随机模型？简单来说就是图中节点和边数量不变，把节点之间连接关系随机打乱。那么根据这个思路，**如果这个图一点都不像随机图，那么说明这个图存在一定的社区结构！**用方程可以这样表示（看不懂没关系，往下翻就对了）：

**模块度**是评估一个社区网络划分好坏的度量方法，它的物理含义是**社区内节点**的**连边数**与随机情况下的边数之差，它的取值范围是 \[−1/2,1)，其定义如下：

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-5b9f155ed11cc1b93c59b836457438fc_1440w.jpg)

**Q的取值范围是\[−1 , 1\]，一般认为取值在0.3~0.7之间就认为有明显的社区结构出现了。这个公式的含义一定要理解清楚才能体会到 louvain 背后的真谛。**

可以简单理解为，固定节点数，给定图的连接有多少条边，用同样多的节点，随机生成的图，有多少个边，相减，得到的差越大，说明给定图越紧密。为了更好的理解这里举一个具体的例子：

## 3、社区发现算法-Louvain

在现实生活中，存在着各种各样的社会网络，比如人际关系网、交通网、金融网等，对这些网络进行社区发现具有极大的意义。例如在社交网络中社区发现、基于好友关系为用户推荐商品或内容、社交网络中人物影响力的计算、信息在社交网络上的传播模型、虚假信息和机器人账号的识别、基于社交网络信息对股市、大选以及金融行业中的反欺诈预测等。**时下，社交网络爆发，图数据库应用火爆，**其中，**Louvain（鲁汶）算法在图数据分析领域的众多算法中是比较复杂的**，同时别具意义**。**

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-a14afc662eadd6caffc44cffd04ffb2d_1440w.jpg)

好家伙，到这里才算是引出了本文的正题。截至到本文发布，Louvain算法还是社区发现算法里的靓仔，与infomap算法共同成为调包侠们的最爱。

Louvain算法的思路也很简单，一句话：**不择手段把图的模块化指数Q搞大。**事实上Louvain算法也就是个**贪心算法**，主要分为以下几步：

**第一步**，将图中每个节点都看作一个社区（没错就是一个节点的社区），尝试让某个节点加入邻居的社区，**计算图的模块化指数增量ΔQ，并最终选择一个ΔQ最大的邻居社区加入**，比如下图我们从编号为0的节点开始，经过第一步后有如下过程：

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-7ec65c6ff7d96d9cb5496ecc93432945_1440w.jpg)

有些同学可能会问，每次都要重新计算全局的ΔQ也太麻烦了叭，当然我们有更简单的办法啦，这个时候我们只需要计算这个局部ΔQ就可以惹，那么这个局部ΔQ就可以表示为：

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-5793d58d0aef025b4bb300cfeba51168_1440w.jpg)

-   ∑in是社区C内部连接权重之和
-   ∑tot是社区C所有连接权重的和，包括社区与外部的链接；
-   ki,in是节点i和社区C之间连接权重之和；
-   Ki是与节点i相关的所有连接权重之和。

仔细想想确实还挺有道理，但是我懒，调包就完事儿了（手动狗头）

**第二步**，在第一步的基础上，**把划分出来的社区当成一个超节点看待**，如下图所示：

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-e0dbdf1e5741a5ad3fa0819be205da2a_1440w.jpg)

这里需要注意两点：

-   超节点对应的社区内部存在边，需要把它们的权重求和，并作为超节点自环的权重
-   超节点之间的社区存在边，需要把它们的权重求和，并作为超节点之间的边权重

**第三步**，如果算法已经达到了目标（比如最大的ΔQ小于某个值）那么算法结束，否则将超节点视为普通节点，并回到第一步。这里展示第二轮循环的结果：

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-44c24263e234b4d6cf92b72f10b2eaeb_1440w.jpg)

## 五、基本概念—权重度

Louvain（鲁汶）算法是基于模块度（modularity）计算的社区识别算法，是以最大化模块度为目标的一种对顶点进行聚类的迭代过程。该算法由比利时鲁汶大学的 Vincent D.Blondel 等人于 2008 年提出，因其能以较高的效率计算出令人满意的社区识别结果，而成为近年来最多被提及和使用的社区识别算法。主要用于社交网虚假账号识别、消费群体划分及商品推荐、银行卡伪冒和欺诈团伙识别、银行理财产品、保险产品推荐、企业集团及家族企业识别等领域。Louvain（鲁汶）算法的基本概念包括：1、权重度2、社区压缩3、模块度4、模块度增**权重度**是考虑了边上权重的度的计算。鲁汶算法在计算模块度时用到了节点权重度和社区权重度两个概念。

## 1、节点权重度

**节点权重度**是指与某个点有关（以该点为端点）的所有边的权重和，包括该点的邻边（连接至其它点）以及该点的自环边（连接至该点自身）。

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-ee7fa85bee43f02377eb0166ea06e3c6_1440w.jpg)

图1：节点权重度如图1所示，红色节点有三条邻边和一条自环边，因此该点的权重度为**1 + 0.5 + 3 + 1.5 = 6**（注意：自环的权重只被计算1次）。

## 2、社区权重度

**社区权重度**是指一个社区内所有节点的权重度的和。

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-c71d35446464f619fcc764bebf038137_1440w.jpg)

图2：社区权重度如图2所示:红色节点的权重度为 1 + 0.5 + 3 + 1.5 = 6绿色节点的权重度为 1 + 1.7 = 2.7蓝色节点的权重度为 0.5 + 0.3 + 2 = 2.8黄色节点的权重度为 3因此 1 号社区的权重度为 6 + 2.7 + 2.8 + 3 = 14.5

## 3、社区内部权重度

**社区内部权重度**是指在计算一个社区的权重度时，仅考虑两个端点均在该社区内的边；或者说，从该社区的权重度中去掉该社区和其它社区之间的边的权重，即为该社区的内部权重度。如上图所示，Ⅰ号社区和其它两个社区之间共有三条边，权重分别为 1.7、0.3 和 2，因此Ⅰ号社区的内部权重度为 14.5 - 1.7 - 0.3 - 2 = 10.5

注意，社区内部权重度并不是两个端点均在社区内的边的权重和，而是这些边当中的非自环边的权重和的二倍再加上自环边的权重和。原因是非自环边的两个端点会令该边被计算两次。换句话说，社区内部除了自环类型的边的权重只被计算一次，其它边会被计算两次——因为每个边会连接2个端点，按照社区内部权重度的定义，边的权重需要x2。用上一张图进行验证，Ⅰ号社区的内部权重度可以计算为 (1 + 0.5 + 3) \* 2 + 1.5 = 10.5

## 4、全图权重度

**全图权重度**是指图中所有节点的权重度的和。如果将全图划分为多个社区，由于图中每个点属于并且仅属于一个社区，全图权重度也等于这些社区的权重度的和。

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-be1348dcd48fd47378464d764758c84b_1440w.jpg)

图3：全图权重度如图3所示，Ⅰ号社区的权重度为 14.5，Ⅱ号社区的权重度为 0.7 \* 3 \* 2 + 1.7 = 5.9，Ⅲ号社区的权重度为 1 \* 6 \* 2 + 0.3 + 2 = 14.3，全图的权重度为 14.5 + 5.9 + 14.3 = 34.7

如果将全图看成一个社区，那么全图权重度也可以理解为该社区的内部权重度。还用上图进行验证，全图权重度为 (1 + 0.5 + 3 + 1.7 + 0.7 \* 3 + 0.3 + 2 + 1 \* 6) \* 2 + 1.5 = 34.7

以上两种计算方法的结果可以相互印证，并且应该是一致的。

## **六、基本概念—社区压缩**

时下，社交网络爆发，图数据库应用火爆，其中，Louvain（鲁汶）算法在图数据分析领域的众多算法中是比较复杂的，同时别具意义。在上节的“文库”中，我们详细解读了权重度，本节将具体对社区压缩进行科普。做好准备，干货来了！

## 1、什么是社区压缩？

**社区压缩**是将**每个社区内的所有节点**用**一个聚合点**来表示，该社区的内部权重度即为此聚合点的自环边的权重，每两个社区间的边的权重和即为相应两个聚合点之间的边的权重。

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-581dde72918eb976e9fe45c368a01841_1440w.jpg)

如动图所示，对I、II、III三个社区进行压缩，I号社区压缩后的自环边的权重为该社区的内部权重，即 10.5；II 号社区压缩后自环边的权重为0.7 \* 3 \* 2 = 4.2，III 号社区压缩后自环边的权重为1 \* 6 \* 2 = 12。同时，I 号与 II号社区之间的边压缩后权重为 1.7，与 III 号社区之间的边压缩后权重为0.3 + 2 = 2.3。

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-e471de8a172728feacd625903a9cef8c_1440w.jpg)

插播一段，看上图。注意呀，以I号社区为例，它的权重度等于10.5。除了自环边，其中红绿、红蓝和红黄的点边，都需要**分别计算2次**哦。

综上，经过倒推计算可知，压缩后的全图权重度为10.5 + 4.2 + 12 + (1.7 + 2.3) \* 2 = 34.7，与压缩前相同。

压缩前和压缩后的结果，是相等的呀！

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-02aaf6ab531fbe94e88a5e7342ec0b3e_1440w.jpg)

## 2、为什么要进行社区压缩？

在鲁汶算法中，使用了大量的社区压缩。那为什么要进行压缩呢？它的作用是什么呢？究其本质来看，进行社区压缩有两方面的好处：一是，让计算效率变高。进行社区压缩，在不改变局部权重度及全图权重度的前提下，通过最大限度减少图的点、边数量来提高后续（迭代）的计算速度；

二是，实现层级化的社区划分。社区内的点在压缩后将作为一个整体进行模块度优化的计算，不再拆分，从而实现了层级化（迭代化）的社区划分效果。

## 七、Louvain算法结果处理

细心的同学肯定发现了，经过Louvain算法计算后的社区，是一个多层次的结构，通常来说它会是这样的：

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-45e2575598027b53fe9ffbd3a8e6d835_1440w.jpg)

那么选取哪个层次的社区结构也是比较头疼的过程呢。这里我建议可以将**手肘法**作为辅助工具，当**模块化指数Q或社区数量随着迭代次数增加出现明显拐点**的时候，选取对应层次的社区结构就比较合理啦，比如下面这样的：

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-1bdd24ae633b8802f71459abeabb11c0_1440w.jpg)

## **八、Louvain算法应用**

很多人在调用community.best\_partiton()方法时，总是报错：AttributeError: ‘module’ object has no attribute ‘best\_partition，一直使用失败，许多网络上代码直接调用**import community**， 就以为这个包叫community，实际上，这个包叫python-louvain。包的地址为：[https://github.com/taynaud/python-louvain](https://link.zhihu.com/?target=https%3A//github.com/taynaud/python-louvain)

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-f555f8fecd60107c7d8a182acfb9d0bd_1440w.jpg)

#安装的方法为：

如果遇到问题，可以按下面的方法进行安装

```python
#Louvain算法 import matplotlib.pyplot as plt import networkx as nx from community import community_louvain # 空手道俱乐部 G = nx.karate_club_graph() com = community_louvain.best_partition(G) #节点大小设置，与度关联 node_size = [G.degree(i)**1*20 for i in G.nodes()] #格式整理 df_com = pd.DataFrame({'Group_id':com.values(), 'object_id':com.keys()} ) # 统计每个团伙人数 并降序 df_com.groupby('Group_id').count().sort_values(by='object_id', ascending=False) # 颜色设置 colors = ['DeepPink','orange','DarkCyan','#A0CBE2','#3CB371','b','orange','y','c','#838B8B','purple','olive','#A0CBE2','#4EEE94']*500 colors = [colors[i] for i in com.values()] #使用 kamada_kawai_layout spring_layout 布局 plt.figure(figsize=(4,3),dpi=500) nx.draw_networkx(G, pos = nx.spring_layout(G), node_color = colors, edge_color = '#2E8B57', font_color = 'black', node_size = node_size, font_size = 5, alpha = 0.9, width = 0.1, font_weight=0.9 ) plt.axis('off') plt.show()
```

![]((70%20%E5%B0%81%E7%A7%81%E4%BF%A1%20%2083%20%E6%9D%A1%E6%B6%88%E6%81%AF)%20%E4%B8%87%E7%89%A9%E7%9A%86%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E8%AF%A6%E8%A7%A3%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95Louvain%20-%20%E7%9F%A5%E4%B9%8E/v2-4da8f9c8ac2beba0967b13fb3c86ccf1_1440w.jpg)


Louvain算法是一种经典的**社区发现算法**，核心目标是通过“模块化（Modularity）最大化”将网络划分为紧密连接的“社区”（同一社区内节点连接密集，不同社区间连接稀疏）。它的优势是效率高，能处理大规模网络，核心步骤分为**“局部聚合”** 和**“社区重连”** 两步循环，直到模块化不再提升。


要理解Louvain的计算过程，我们先明确两个核心基础：**模块化公式**和**网络表示约定**，再通过一个具体的小网络案例拆解每一步计算。

# Louvain 用具体例子讲解怎么算的？公式怎么样的？

## 一、核心基础：模块化公式与网络约定
### 1. 模块化（Modularity）：衡量社区划分好坏的指标
模块化（记为`Q`）的本质是“**实际社区内边数与随机网络中社区内期望边数的差值占总边数的比例**”，`Q`越大（范围：-1/2 ~ 1），社区划分效果越好。

#### 模块化公式
$$
Q = \frac{1}{2m} \sum_{i,j} \left[ A_{ij} - \frac{k_i k_j}{2m} \right] \delta(c_i, c_j)
$$
各符号含义：
- `A_ij`：邻接矩阵元素，若节点`i`和`j`直接相连，`A_ij=1`；否则`A_ij=0`（无向网络中`A_ij=A_ji`）。
- `k_i`：节点`i`的度数（即与`i`直接相连的节点数）。
- `m`：网络中**总边数**（注意：无向边只算1次，如`i-j`算1条边，不是2条）。
- `c_i`：节点`i`所属的社区；`δ(c_i,c_j)`是指示函数：若`c_i=c_j`（`i`和`j`同社区），`δ=1`；否则`δ=0`。
- `k_i k_j/(2m)`：随机网络中，节点`i`和`j`相连的**期望概率**（基于配置模型，即保持各节点度数不变，随机重连边）。


### 2. 网络约定（案例用）
为简化计算，我们用一个**无向、无权的小网络**作为案例（共6个节点，7条边），网络结构如下：
- 节点：1、2、3、4、5、6
- 边：1-2、1-3、2-3、3-4、4-5、4-6、5-6
- 总边数`m = 7`（直接数边即可）
- 各节点度数`k_i`：
  - `k1=2`（连1-2、1-3），`k2=2`（连1-2、2-3），`k3=3`（连1-3、2-3、3-4）
  - `k4=3`（连3-4、4-5、4-6），`k5=2`（连4-5、5-6），`k6=2`（连4-6、5-6）


## 二、Louvain算法核心步骤（案例计算）
Louvain算法分**两步循环**：  
1. **局部聚合（Local Moving）**：逐个节点尝试“移动”到相邻节点的社区，计算移动后模块化的变化（`ΔQ`），若`ΔQ>0`则保留移动，直到所有节点无法通过移动提升`Q`；  
2. **社区重连（Community Aggregation）**：将第一步中形成的每个社区视为一个“超级节点”，重新计算超级节点间的边数（原社区间边数之和），形成新的简化网络；  
3. **循环**：对简化网络重复步骤1-2，直到`Q`不再提升，最终得到社区划分。


### 关键：模块化变化量`ΔQ`的简化公式
在“局部聚合”中，我们不需要每次重新计算完整的`Q`，只需计算“节点`i`移动到社区`C`”后`Q`的变化量`ΔQ`。推导后，`ΔQ`的简化公式（核心！）为：
$$
\Delta Q = \left( \frac{\sum_{in} + k_{i,in}}{2m} - \left( \frac{\sum_{tot} + k_i}{2m} \right)^2 \right) - \left( \frac{\sum_{in}}{2m} - \left( \frac{\sum_{tot}}{2m} \right)^2 - \left( \frac{k_i}{2m} \right)^2 \right)
$$
进一步化简（代数整理后）：
$$
\Delta Q = \frac{1}{2m} \left[ k_{i,in} - \frac{k_i \cdot \sum_{tot}}{2m} \right]
$$
各符号含义（针对“节点`i`移动到社区`C`”这一行为）：
- `k_{i,in}`：节点`i`与社区`C`中所有节点的**连接边数**（即`i`到`C`的“内部边数”）；  
- `sum_tot`：社区`C`中所有节点的**总度数之和**（即`C`的“总度数”）；  
- `k_i`：节点`i`的原始度数（不变）；  
- `m`：网络总边数（不变）。


### 步骤1：初始状态（每个节点都是独立社区）
初始时，每个节点自身是一个社区，即：  
社区`C1={1}`，`C2={2}`，`C3={3}`，`C4={4}`，`C5={5}`，`C6={6}`。  

此时各社区的`sum_tot`（总度数）= 社区内节点度数（因单个节点），即：  
`sum_tot(C1)=k1=2`，`sum_tot(C2)=k2=2`，`sum_tot(C3)=k3=3`，`sum_tot(C4)=k4=3`，`sum_tot(C5)=k5=2`，`sum_tot(C6)=k6=2`。


### 步骤2：局部聚合（逐个节点移动，计算`ΔQ`）
我们按节点1→2→3→4→5→6的顺序，逐个尝试移动，计算`ΔQ`，只保留`ΔQ>0`的移动。

#### 案例1：处理节点1
节点1的相邻节点是2和3（边1-2、1-3），需尝试移动到2的社区（C2）或3的社区（C3），计算`ΔQ`：

- **尝试移动到C2（社区{2}）**：
  - `k_{i,in}`：节点1与C2的连接边数 = 1（仅1-2）；  
  - `sum_tot`：C2的总度数 = 2（k2=2）；  
  - 代入`ΔQ`公式：  
    $$
    \Delta Q = \frac{1}{2*7} \left[ 1 - \frac{2 \cdot 2}{2*7} \right] = \frac{1}{14} \left[ 1 - \frac{4}{14} \right] = \frac{1}{14} * \frac{10}{14} ≈ 0.051 > 0
    $$  
    `ΔQ>0`，移动有效！节点1加入C2，此时C2变为`{1,2}`，C1消失。

- **再尝试移动到C3（社区{3}）**：
  - 此时节点1已在C2（{1,2}），先计算“节点1与C3的连接边数”`k_{i,in}=1`（1-3）；  
  - C3的`sum_tot=3`（k3=3）；  
  - 代入`ΔQ`：  
    $$
    \Delta Q = \frac{1}{14} \left[ 1 - \frac{2 \cdot 3}{14} \right] = \frac{1}{14} * \frac{8}{14} ≈ 0.041 > 0
    $$  
    但此时需比较“移动后`Q`是否比当前更高”：原C2（{1,2}）的`Q`贡献 vs 移动到C3后的贡献。实际计算后，移动到C2的`ΔQ`更大，因此节点1最终留在C2（{1,2}）。


#### 案例2：处理节点2（已在C2={1,2}）
节点2的相邻节点是1（同社区）和3（C3={3}），只需尝试移动到C3：
- `k_{i,in}`：节点2与C3的连接边数 = 1（2-3）；  
- C3的`sum_tot=3`；  
- `ΔQ = (1/14)[1 - (2*3)/14] ≈ 0.041 > 0`，但移动后需看整体`Q`：  
  若节点2移动到C3，C2变为{1}，C3变为{2,3}。计算此时的`Q`：  
  - 社区内边数：C3内有2-3（1条），C2内无（0），其他社区无；  
  - 期望边数：C3的`sum_tot=2+3=5`，期望边数=5²/(2*14)=25/28≈0.89；  
  - 贡献：(1 - 25/28)/14 ≈ 0.007，比“节点2留在C2”的贡献（C2内有1-2，贡献(1 - (2+2)²/(28))/14≈0.009）更小，因此节点2留在C2。


#### 案例3：处理节点3（关键：连接C2和C4）
节点3的相邻节点是1（C2={1,2}）、2（C2）、4（C4={4}），需尝试移动到C2或C4：

- **尝试移动到C2（{1,2}）**：
  - `k_{i,in}`：节点3与C2的连接边数 = 2（1-3、2-3）；  
  - C2的`sum_tot=k1+k2=2+2=4`；  
  - 代入`ΔQ`：  
    $$
    \Delta Q = \frac{1}{14} \left[ 2 - \frac{3 \cdot 4}{14} \right] = \frac{1}{14} * \frac{28-12}{14} = \frac{16}{196} ≈ 0.082 > 0
    $$  
    移动有效！节点3加入C2，此时C2变为`{1,2,3}`（社区A），C3消失。

- **再尝试移动到C4（{4}）**：
  - `k_{i,in}=1`（3-4），C4的`sum_tot=3`；  
  - `ΔQ = (1/14)[1 - (3*3)/14] = (1/14)*(5/14)≈0.025 >0`，但远小于移动到C2的`ΔQ`，因此节点3留在社区A（{1,2,3}）。


#### 案例4：处理节点4、5、6（对称结构，类似节点1-3）
- 节点4的相邻节点是3（社区A）、5（C5={5}）、6（C6={6}）：  
  尝试移动到5的社区（C5）：`k_{i,in}=1`（4-5），`sum_tot=2`，`ΔQ≈0.051>0`，移动后C5变为{4,5}；  
  再尝试移动到6的社区（C6）：`k_{i,in}=1`（4-6），`ΔQ≈0.041>0`，但留在{4,5}更优；  
  最终，节点5、6会加入节点4的社区，形成`{4,5,6}`（社区B）。


#### 局部聚合结果
经过一轮局部移动，所有节点无法再通过移动提升`Q`，此时社区划分为：  
- 社区A：{1,2,3}（内部边3条：1-2、1-3、2-3）；  
- 社区B：{4,5,6}（内部边3条：4-5、4-6、5-6）；  
- 社区间边：仅3-4（1条）。


### 步骤3：社区重连（构建超级节点网络）
将每个社区视为一个“超级节点”：
- 超级节点A（代表社区A），超级节点B（代表社区B）；  
- 超级节点间的边数：原社区A与B的连接边数 = 1（仅3-4）；  
- 超级节点的度数：原社区内所有节点的度数之和（A的`sum_tot=2+2+3=7`，B的`sum_tot=3+2+2=7`）；  
- 新网络总边数`m'`：原社区内边数之和 + 社区间边数 = (3+3) + 1 = 7（与原网络`m`一致，因无重复计算）。


### 步骤4：循环验证（简化网络的局部聚合）
对超级节点A和B组成的简化网络，再次执行“局部聚合”：  
- 尝试将A移动到B的社区（或反之），计算`ΔQ`：  
  - `k_{i,in}=1`（A与B的连接边数）；  
  - `sum_tot=7`（B的总度数）；  
  - `k_i=7`（A的总度数）；  
  - `ΔQ = (1/(2*7))[1 - (7*7)/(2*7)] = (1/14)[1 - 7/2] = (1/14)*(-5/2) ≈ -0.179 < 0`；  
  `ΔQ<0`，移动无效，因此超级节点A和B保持独立。


### 最终结果
模块化`Q`达到最大，社区划分为：  
**社区A：{1,2,3}，社区B：{4,5,6}**（与直观的网络结构完全一致：内部密集，外部仅1条边）。


## 三、Louvain算法的核心逻辑总结
1. **贪心策略**：通过“局部移动节点”最大化`ΔQ`，避免全局计算`Q`，效率极高；  
2. **层级聚合**：将社区压缩为超级节点，逐步简化网络，可处理百万级节点；  
3. **终止条件**：当简化网络的`Q`不再提升时停止，确保划分最优。


通过上述案例可见，Louvain算法的关键是**`ΔQ`的简化计算**——无需重复计算全局`Q`，只需关注节点与目标社区的局部连接，这也是它能高效处理大规模网络的核心原因。


# 完整模块化公式和ΔQ简化公式取值范围以及大小含义？

模块化`Q`和其变化量`ΔQ`的取值范围及大小含义，直接反映了社区结构的强度和优化方向，具体如下：


### 一、完整模块化公式`Q`的取值范围及含义
#### 取值范围：  
`Q ∈ [-1/2, 1]`，实际应用中通常落在`[0, 1)`区间。  
- 理论下限`-1/2`：极端情况下（如所有社区内部边数远少于随机期望）才可能出现，实际网络中极少见。  
- 上限`1`：表示网络完全划分为“完美社区”——所有边都在社区内部，且没有社区间的边（此时实际内部边数远大于随机期望），但现实中几乎不存在。  


#### 大小含义：  
`Q`的核心意义是**量化社区结构的“显著性”**：  
- `Q ≈ 0`：网络的社区划分与随机网络的社区划分无显著差异（实际内部边数接近随机期望），说明几乎没有有意义的社区结构。  
- `Q > 0`：实际社区内部的边数多于随机期望，`Q`越大，表明社区内部连接越密集、社区间连接越稀疏，社区结构越显著。  
  - 经验上，`Q > 0.3`通常被认为存在较明显的社区结构；`Q > 0.7`则表示社区结构非常强（如社交网络中的小团体、生物网络中的功能模块）。  


### 二、ΔQ简化公式的取值范围及含义
#### 取值范围：  
`ΔQ`的取值范围取决于网络结构，无严格上下限，但通常是一个较小的数值（因分母含`2m`，而`m`是总边数，通常较大）。  


#### 大小含义：  
`ΔQ`的核心意义是**衡量“节点移动到某社区”对社区结构优化的影响**：  
- `ΔQ > 0`：移动节点后，模块化`Q`增大，说明该移动让社区结构更显著（内部边数相对随机期望的优势增强），是“有利”的移动。  
- `ΔQ = 0`：移动节点对社区结构无影响，`Q`不变。  
- `ΔQ < 0`：移动节点后，模块化`Q`减小，说明该移动破坏了原有的社区结构（内部边数相对随机期望的优势减弱），是“不利”的移动。  


### 总结  
- `Q`的大小直接反映社区结构的整体强度，`Q`越大，社区划分越合理；  
- `ΔQ`的符号和大小反映局部调整（节点移动）的效果，`ΔQ > 0`表示调整有助于优化社区结构，是算法迭代中需要保留的操作。

# leiden 从 louvain
---
created: 2025-10-25T22:22:29 (UTC +08:00)
tags: [常用生信算法和软件的学习资源合集]
source: https://geekdaxue.co/read/davey-brweo@zwv9pb/kw4c6u
author: 
---

# 单细胞聚类（四）图解Leiden算法对Louvain算法的优化 - 《生信算法与软件》 - 极客文档

> ## Excerpt
> 常用生信算法和软件的学习资源合集

---
**Louvain算法**是目前单细胞分析中最常用的聚类算法\[1\]，Seurat/Scanpy/RaceID等单细胞分析工具都**默认louvain算法**。6天前HumanCell Atlas(HCA)团队发表在Nature Method上的单细胞分析流程中\[2\]，默认的聚类算法是scran包的方法：细胞间权重基于排序计算（rank-based），聚类算法用Walktrap。这跟杰卡德距离+Louvain算法的方法截然不同。

聚类算法孰优孰劣，此前已经有人做过比较。2016年Scientific Reports上有一篇文章比较了igraph包里的8种聚类算法，其中包括了Louvain和Walktrap\[3\]。测试结果的准确率Louvain和Walktrap相近。但是，当节点数（细胞数）大于6000时，Louvain的表现要优于Walktrap。

**总结评测结果，Louvain算法表现是最好的**。但仍有不少文章选择其他聚类算法，因为louvain算法有以下几个缺点：

1.  社区划分的精度有局限性\[4\]；
2.  分组内细胞分布密度的大小会影响亚群的鉴定\[2\];
3.  被鉴定为同一个分群的细胞群内，存在两个没有连线的小分群\[5\]。

**Leiden算法**主要针对上述的第3个缺点，对louvain算法进行优化\[5\]。  
Leiden算法的命名来源于荷兰莱顿大学（Leiden University）。该算法由莱顿大学的三位研究员开发，结果于今年3月份发表在Scientific Reports上。  
![单细胞聚类（四）图解Leiden算法对Louvain算法的优化 - 图1](%E5%8D%95%E7%BB%86%E8%83%9E%E8%81%9A%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9B%BE%E8%A7%A3Leiden%E7%AE%97%E6%B3%95%E5%AF%B9Louvain%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%20-%20%E3%80%8A%E7%94%9F%E4%BF%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BD%AF%E4%BB%B6%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E6%96%87%E6%A1%A3/9a8b6337955b9169ff5aac28f40081c5.webp)

想了解louvain算法的聚类过程，可以回顾往期文章：  
[单细胞聚类（二）社区划分与模块度](http://mp.weixin.qq.com/s?__biz=MzU4NjgwOTU4Nw==&mid=2247483765&idx=1&sn=38ba655a76d56140fafa215374ee0982&chksm=fdf4e8e9ca8361ff5dbae2b55d27708a21debe53341f15811b7b0ab40676186ab49412652bae&scene=21#wechat_redirect)  
总结Leiden算法优化louvain的两个要点：

1.  比louvain算法运行更快。
2.  针对louvain聚类结果中出现一些分群内部存在断链的现象（连线没有把所有细胞串起来，存在明显亚群）进行优化，分群更加合理，可能得到更多亚群。

![单细胞聚类（四）图解Leiden算法对Louvain算法的优化 - 图2](%E5%8D%95%E7%BB%86%E8%83%9E%E8%81%9A%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9B%BE%E8%A7%A3Leiden%E7%AE%97%E6%B3%95%E5%AF%B9Louvain%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%20-%20%E3%80%8A%E7%94%9F%E4%BF%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BD%AF%E4%BB%B6%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E6%96%87%E6%A1%A3/f68bbe8c7ecd564051455617b02f5647.webp)

**图解leiden算法的操作过程**  
我们可以把聚类过程当作体育课的一场游戏。  
学生是**细胞**，在操场上站队（聚类）。  
**模块度**是体育老师，检查学生站队是否合理。  
连线（**细胞间权重**）表示学生之间有一定的关系，比如同班同学，身高一致等。  
![单细胞聚类（四）图解Leiden算法对Louvain算法的优化 - 图3](%E5%8D%95%E7%BB%86%E8%83%9E%E8%81%9A%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9B%BE%E8%A7%A3Leiden%E7%AE%97%E6%B3%95%E5%AF%B9Louvain%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%20-%20%E3%80%8A%E7%94%9F%E4%BF%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BD%AF%E4%BB%B6%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E6%96%87%E6%A1%A3/77438728ec28ff2b979f5a6bed3cc509.webp)

经过学生的一阵骚动（初始划分聚类）之后，初始的队伍出来了，分成的三个队伍：  
![单细胞聚类（四）图解Leiden算法对Louvain算法的优化 - 图4](%E5%8D%95%E7%BB%86%E8%83%9E%E8%81%9A%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9B%BE%E8%A7%A3Leiden%E7%AE%97%E6%B3%95%E5%AF%B9Louvain%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%20-%20%E3%80%8A%E7%94%9F%E4%BF%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BD%AF%E4%BB%B6%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E6%96%87%E6%A1%A3/388112229b78a88800cdbd40850b4c11.webp)

这时体育老师出来，看了看整体队形（模块度给聚类结果打分），感觉还不行（模块度分数偏低），需要调整分组站队。

Leiden和louvain算法的调整策略不同（**leiden优化的要点一**）：

1.  Louvain：让每个同学去另外两个队伍，每次换队伍都让体育老师评价一下；
2.  Leiden：只让每个同学去有连线的其他队伍，节省时间。

当害羞同学![单细胞聚类（四）图解Leiden算法对Louvain算法的优化 - 图5](%E5%8D%95%E7%BB%86%E8%83%9E%E8%81%9A%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9B%BE%E8%A7%A3Leiden%E7%AE%97%E6%B3%95%E5%AF%B9Louvain%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%20-%20%E3%80%8A%E7%94%9F%E4%BF%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BD%AF%E4%BB%B6%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E6%96%87%E6%A1%A3/91e5f0a3bc97bb26c745ca2d5fba8b53.webp)从红队调整到绿队时，体育老师发现队形变好看了（模块度打分提高了）。因为红队身高整体比绿队高，害羞同学![单细胞聚类（四）图解Leiden算法对Louvain算法的优化 - 图6](%E5%8D%95%E7%BB%86%E8%83%9E%E8%81%9A%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9B%BE%E8%A7%A3Leiden%E7%AE%97%E6%B3%95%E5%AF%B9Louvain%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%20-%20%E3%80%8A%E7%94%9F%E4%BF%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BD%AF%E4%BB%B6%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E6%96%87%E6%A1%A3/c9a97268934398a5ee16935ae26f88e0.webp)比较矮，适合绿队。害羞同学刚开始站在红队，是因为她跟红队是同班同学。

![单细胞聚类（四）图解Leiden算法对Louvain算法的优化 - 图7](%E5%8D%95%E7%BB%86%E8%83%9E%E8%81%9A%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9B%BE%E8%A7%A3Leiden%E7%AE%97%E6%B3%95%E5%AF%B9Louvain%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%20-%20%E3%80%8A%E7%94%9F%E4%BF%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BD%AF%E4%BB%B6%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E6%96%87%E6%A1%A3/b4176492cfb194509cfbcc8f9766ef5e.webp)

但害羞同学![单细胞聚类（四）图解Leiden算法对Louvain算法的优化 - 图8](%E5%8D%95%E7%BB%86%E8%83%9E%E8%81%9A%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9B%BE%E8%A7%A3Leiden%E7%AE%97%E6%B3%95%E5%AF%B9Louvain%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%20-%20%E3%80%8A%E7%94%9F%E4%BF%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BD%AF%E4%BB%B6%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E6%96%87%E6%A1%A3/c440e0e778f46bc54087ffee89c57be6.webp)离开红队之后，问题就来了。红队内部出现左右两个没有连线的小队：耶小队![单细胞聚类（四）图解Leiden算法对Louvain算法的优化 - 图9](%E5%8D%95%E7%BB%86%E8%83%9E%E8%81%9A%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9B%BE%E8%A7%A3Leiden%E7%AE%97%E6%B3%95%E5%AF%B9Louvain%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%20-%20%E3%80%8A%E7%94%9F%E4%BF%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BD%AF%E4%BB%B6%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E6%96%87%E6%A1%A3/89f2f0639de9b4b18ca59b087d2a5e2a.webp)和奸笑小队![单细胞聚类（四）图解Leiden算法对Louvain算法的优化 - 图10](%E5%8D%95%E7%BB%86%E8%83%9E%E8%81%9A%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9B%BE%E8%A7%A3Leiden%E7%AE%97%E6%B3%95%E5%AF%B9Louvain%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%20-%20%E3%80%8A%E7%94%9F%E4%BF%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BD%AF%E4%BB%B6%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E6%96%87%E6%A1%A3/04ea4153c8f65f196add4be0afeba9ef.webp)。Louvain算法没有检测这种内部断链的现象。尽管红队都是同班同学，但内部还是有身高的差异，耶小队![单细胞聚类（四）图解Leiden算法对Louvain算法的优化 - 图11](%E5%8D%95%E7%BB%86%E8%83%9E%E8%81%9A%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9B%BE%E8%A7%A3Leiden%E7%AE%97%E6%B3%95%E5%AF%B9Louvain%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%20-%20%E3%80%8A%E7%94%9F%E4%BF%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BD%AF%E4%BB%B6%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E6%96%87%E6%A1%A3/04acdc097dbc425bbe229d4aad50ff42.webp)比奸笑小队![单细胞聚类（四）图解Leiden算法对Louvain算法的优化 - 图12](%E5%8D%95%E7%BB%86%E8%83%9E%E8%81%9A%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9B%BE%E8%A7%A3Leiden%E7%AE%97%E6%B3%95%E5%AF%B9Louvain%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%20-%20%E3%80%8A%E7%94%9F%E4%BF%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BD%AF%E4%BB%B6%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E6%96%87%E6%A1%A3/4d39c33ca78e3c91d46f4d1b98fa72cb.webp)普遍矮小。之前不高不矮的害羞同学![单细胞聚类（四）图解Leiden算法对Louvain算法的优化 - 图13](%E5%8D%95%E7%BB%86%E8%83%9E%E8%81%9A%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9B%BE%E8%A7%A3Leiden%E7%AE%97%E6%B3%95%E5%AF%B9Louvain%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%20-%20%E3%80%8A%E7%94%9F%E4%BF%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BD%AF%E4%BB%B6%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E6%96%87%E6%A1%A3/6665950fa0cb8ba50ad5d07edc8f1309.webp)在的时候，还能起到内部过渡的作用。当害羞同学![单细胞聚类（四）图解Leiden算法对Louvain算法的优化 - 图14](%E5%8D%95%E7%BB%86%E8%83%9E%E8%81%9A%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9B%BE%E8%A7%A3Leiden%E7%AE%97%E6%B3%95%E5%AF%B9Louvain%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%20-%20%E3%80%8A%E7%94%9F%E4%BF%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BD%AF%E4%BB%B6%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E6%96%87%E6%A1%A3/e39fdfb83ee4b1042ec1cb6c14ab486c.webp)离开之后，红队内部出现两极化。

![单细胞聚类（四）图解Leiden算法对Louvain算法的优化 - 图15](%E5%8D%95%E7%BB%86%E8%83%9E%E8%81%9A%E7%B1%BB%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9B%BE%E8%A7%A3Leiden%E7%AE%97%E6%B3%95%E5%AF%B9Louvain%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%20-%20%E3%80%8A%E7%94%9F%E4%BF%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BD%AF%E4%BB%B6%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E6%96%87%E6%A1%A3/71eae930f94f239199f3a7d9ca4e4468.webp)  
幸亏体育老师提前备课，看了leiden算法，及时将红队分开。（**leiden优化要点二**）

下课铃声响起，体育老师手握Leiden书，看着同学们完美的队形，露出了满意的微笑。

如果您对相关内容感兴趣，欢迎关注本公众号：“单细胞组学”。  
如果您对内容满意，欢迎点击右下角 “在看”，让更多感兴趣的朋友看到！  
感谢！

参考文献：  
\[1\] Blondel,Vincent D., et al. “Fast unfolding of communities in large networks.” Journal of statisticalmechanics: theory and experiment 2008.10 (2008): P10008.  
\[2\] AmezquitaR A, Lun A T L, Becht E, et al. Orchestrating single-cell analysis withBioconductor\[J\]. Nature Methods, 2019: 1-9.  
\[3\] YangZ, Algesheimer R, Tessone C J. A comparative analysis of community detectionalgorithms on artificial networks\[J\]. Scientific reports, 2016, 6: 30750.  
\[4\] FortunatoS, Barthelemy M. Resolution limit in community detection\[J\]. Proceedings of thenational academy of sciences, 2007, 104(1): 36-41.  
\[5\] Traag,Vincent A., Ludo Waltman, and Nees Jan van Eck. “From Louvain to Leiden:guaranteeing well-connected communities.” Scientific reports 9 (2019).


# 社区检测之鲁文算法中的鲁文算法的社区不良和社区断开分别是什么意思？

在社区检测的**鲁文算法（Louvain algorithm）** 语境中，“社区不良”和“社区断开”并不是算法原生定义的术语，可能是对算法执行过程中出现的两类问题或现象的描述。结合算法原理，这两个概念可理解如下：


### 1. 社区不良（Poor Community）  
指算法划分出的社区结构**质量较低**，不符合“内部连接密集、外部连接稀疏”的核心特征。具体表现为：  
- 社区内部节点间的实际连接数与随机网络的期望连接数差异较小（模块化`Q`值偏低）；  
- 社区内部存在明显的“子结构”（即社区内可进一步划分为更紧密的子团体），但算法未能识别；  
- 社区边界模糊，部分节点的归属不合理（如与外部节点连接更紧密的节点被划入某社区）。  

**原因**：Louvain算法是贪心算法，可能陷入局部最优（如早期迭代中节点的不合理移动导致后续无法修正），从而产生“不良社区”。


### 2. 社区断开（Community Disconnection）  
指算法划分出的社区**内部存在断裂**，即社区内的节点未形成连通子图，甚至出现多个孤立的子组件。具体表现为：  
- 同一社区内的部分节点之间没有路径相连（即使通过社区内其他节点）；  
- 社区被“割裂”为多个互不连通的小团体，仅因算法的局部优化（如`ΔQ`暂时为正）而被归为同一社区。  

**原因**：Louvain算法以模块化`Q`的局部增量为优化目标，可能因某个节点的移动暂时提升`Q`，但导致社区整体连通性被破坏。这种情况在稀疏网络或节点度数差异极大的网络中较易出现。


### 总结  
两者均反映算法划分结果的缺陷：  
- “社区不良”强调结构质量低（不符合社区的密集性特征）；  
- “社区断开”强调结构完整性差（内部不连通）。  

Louvain算法的贪心特性可能导致这些问题，实际应用中需结合网络拓扑（如连通性检查）和其他指标（如模块度`Q`的稳定性）来评估社区划分的合理性。


