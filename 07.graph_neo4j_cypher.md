
## 图数据库 Neo4j  Cypher 语法

[教程目录](http://neo4j.com.cn/topic/67f4cf91455186f56d9f412f) 
引自：https://neo4j.com/docs/getting-started/appendix/graphdb-concepts/

### Neo4j 概念
http://neo4j.com.cn/topic/67f4cbcf455186f56d9f412d


# 图数据库概念

## 简介

本指南涵盖图数据库的基础知识。

Neo4j 使用属性图数据库模型。图数据结构由节点（离散对象）组成，这些节点可以通过关系连接。下图是一个包含三个节点（圆圈）和三个关系（箭头）的图的示例。 ![image](https://neo4j.com/docs/getting-started/_images/graph_concept_three_nodes-arr.svg) ![图 1. 图结构的概念](插入图 1 的链接)

Neo4j 属性图数据库模型包括：

- **节点**：描述域的实体（离散对象）。
- **标签**：节点可以有零个或多个标签，用于定义（分类）它们是什么类型的节点。
- **关系**：描述源节点和目标节点之间的连接。
- **方向**：关系始终具有方向（单向）。
- **类型**：关系必须具有类型（一种类型），用于定义（分类）它们是什么类型的关系。
- **属性**：节点和关系可以具有属性（键值对），用于进一步描述它们。

在数学中，图论是研究图的学科。

在图论中：

- 节点也称为顶点或点。
- 关系也称为边、链接或线。

## 示例图

下图介绍了属性图的基本概念： ![image](https://neo4j.com/docs/getting-started/_images/graph_simple-arr.svg)

![图 2. 示例图](插入图 2 的链接)

要创建示例图，请使用 Cypher® 子句 `CREATE`。

```cypher
CREATE (:Person:Actor {name: 'Tom Hanks', born: 1956})-[:ACTED_IN {roles: ['Forrest']}]->(:Movie {title: 'Forrest Gump', released: 1994})<-[:DIRECTED]-(:Person {name: 'Robert Zemeckis', born: 1951})
```

## 节点

节点用于表示域的实体（离散对象）。

最简单的图是单个节点，没有关系。 考虑以下图，它由一个节点组成。 ![image](https://neo4j.com/docs/getting-started/_images/graph_single_node-arr.svg) ![图 3. 节点](插入图 3 的链接)

节点标签是：

- Person
- Actor

属性是：

- name: Tom Hanks
- born: 1956

可以使用 Cypher 使用以下查询创建节点：

```cypher
CREATE (:Person:Actor {name: 'Tom Hanks', born: 1956})
```

## 节点标签

标签通过将节点分组（分类）到集合中来塑造域，其中具有特定标签的所有节点都属于同一集合。

例如，所有表示用户的节点都可以标记为标签 `User`。 这样，您可以要求 Neo4j 仅对您的用户节点执行操作，例如查找具有给定名称的所有用户。

由于标签可以在运行时添加和删除，因此它们也可以用于标记节点的临时状态。 `Suspended` 标签可用于表示已暂停的银行帐户，而 `Seasonal` 标签可以表示当前处于季节性的蔬菜。

一个节点可以有零个或多个标签。

在示例图中，节点标签 `Person`、`Actor` 和 `Movie` 用于描述（分类）节点。 可以添加更多标签来表达数据的不同维度。

下图显示了多个标签的使用。 ![image](https://neo4j.com/docs/getting-started/_images/graphdb-simple-labels-multi-arr.svg) ![图 4. 多个标签](插入图 4 的链接)

## 关系

关系描述了源节点和目标节点之间的连接是如何相关的。 节点可以与自身建立关系。

关系：

- 连接源节点和目标节点。
- 具有方向（单向）。
- 必须具有类型（一种类型），用于定义（分类）它是什么类型的关系。
- 可以具有属性（键值对），用于进一步描述关系。

关系将节点组织成结构，使图可以类似于列表、树、地图或复合实体 - 它们中的任何一个都可以组合成更复杂、更丰富地互连的结构。 ![image](https://neo4j.com/docs/getting-started/_images/graph_example_relationship-arr.svg) ![图 5. 关系](插入图 5 的链接)

关系类型：`ACTED_IN`

属性是：

- roles: [‘Forrest’]
- performance: 5

`roles` 属性具有一个数组值，其中包含一个项目（‘Forrest’）。

可以使用 Cypher 使用以下查询创建关系：

```cypher
CREATE ()-[:ACTED_IN {roles: ['Forrest'], performance: 5}]->()
```

您必须创建或引用源节点和目标节点才能创建关系。

关系始终具有方向。 但是，在没有用的情况下，可以忽略方向。 这意味着没有必要在相反方向上添加重复关系，除非需要正确描述数据模型。

一个节点可以与自身建立关系。 要表达 Tom Hanks 认识自己，可以表示为： ![image](https://neo4j.com/docs/getting-started/_images/graphdb-nodes-and-rel-self-arr.svg) ![图 6. 与单个节点的关系](插入图 6 的链接)

## 关系类型

关系必须只有一个关系类型。

下面是一个 `ACTED_IN` 关系，其中 `Tom Hanks` 节点作为源节点，`Forrest Gump` 作为目标节点。 ![image](https://neo4j.com/docs/getting-started/_images/graphdb-nodes-and-rel-arr.svg) ![图 7. 关系类型](插入图 7 的链接)

观察到 `Tom Hanks` 节点具有传出关系，而 `Forrest Gump` 节点具有传入关系。

## 属性

属性是键值对，用于在节点和关系上存储数据。

属性的值部分：

- 可以保存不同的数据类型，例如数字、字符串或布尔值。
- 可以保存包含同类列表（数组），例如字符串、数字或布尔值。

**示例 1. 数字**

```cypher
CREATE (:Example {a: 1, b: 3.14})
```

属性 `a` 的类型为整数，值为 `1`。

属性 `b` 的类型为浮点数，值为 `3.14`。

**示例 2. 字符串和布尔值**

```cypher
CREATE (:Example {c: 'This is an example string', d: true, e: false})
```

属性 `c` 的类型为字符串，值为 `'This is an example string'`。

属性 `d` 的类型为布尔值，值为 `true`。

属性 `e` 的类型为布尔值，值为 `false`。

**示例 3. 列表**

```cypher
CREATE (:Example {f: [1, 2, 3], g: [2.71, 3.14], h: ['abc', 'example'], i: [true, true, false]})
```

属性 `f` 包含一个数组，其值为 `[1, 2, 3]`。

属性 `g` 包含一个数组，其值为 `[2.71, 3.14]`。

属性 `h` 包含一个数组，其值为 `['abc', 'example']`。

属性 `i` 包含一个数组，其值为 `[true, true, false]`。

有关可用数据类型的完整描述，请参阅 [Cypher 手册 → 值和类型](链接到 Cypher 手册)。

## 遍历和路径

遍历是您查询图以查找问题答案的方式，例如：“我的朋友喜欢但我还没有拥有的音乐是什么？”，或者“如果此电源发生故障，哪些 Web 服务会受到影响？”。

遍历图意味着按照某些规则通过跟随关系来访问节点。 在大多数情况下，仅访问图的子集。

**示例 4. 路径匹配。**

要根据小型示例数据库找出 Tom Hanks 参演了哪些电影，遍历将从 `Tom Hanks` 节点开始，跟随连接到该节点的任何 `ACTED_IN` 关系，并以 `Movie` 节点 `Forrest Gump` 作为结果结束（参见黑线）： ![image](https://neo4j.com/docs/getting-started/_images/graphdb-traversal-arr.svg) 遍历结果可以作为长度为 1 的路径返回： ![image](https://neo4j.com/docs/getting-started/_images/graphdb-path-arr.svg) 最短的可能路径的长度为零。 它包含一个节点，没有关系。

仅包含单个节点的路径的长度为 0。 ![image](https://neo4j.com/docs/getting-started/_images/graphdb-path-zero-arr.svg) ![图 8. 长度为零的路径](插入图 8 的链接)

包含一个关系的路径的长度为 1。 ![image](https://neo4j.com/docs/getting-started/_images/graphdb-path-example-loop-arr.svg) ![图 9. 长度为 1 的路径](插入图 9 的链接)

## 模式

Neo4j 中的模式是指索引和约束。

Neo4j 通常被描述为“模式可选”，这意味着没有必要创建索引和约束。 您可以创建数据 - 节点、关系和属性 - 而无需预先定义模式。 可以在需要时引入索引和约束，以获得性能或建模优势。

### 索引

索引用于提高性能。 要查看如何使用索引的示例，请参阅使用索引。 有关如何在 Cypher 中使用索引的详细说明，请参阅 [Cypher 手册 → 索引](链接到 Cypher 手册中的索引部分)。

### 约束

约束用于确保数据符合域的规则。 要查看如何使用约束的示例，请参阅使用约束。 有关如何在 Cypher 中使用约束的详细说明，请参阅 [Cypher 手册 → 约束](链接到 Cypher 手册中的约束部分)。

## 命名约定

节点标签、关系类型和属性（键部分）区分大小写，这意味着例如，属性 `name` 与属性 `Name` 不同。

建议使用以下命名约定：

表 1. 命名约定

| 图实体   | 推荐风格                 | 示例                                    |
| :------- | :----------------------- | :-------------------------------------- |
| 节点标签 | 驼峰式，以大写字符开头   | `:VehicleOwner` 而不是 `:vehicle_owner` |
| 关系类型 | 大写，使用下划线分隔单词 | `:OWNS_VEHICLE` 而不是 `:ownsVehicle`   |
| 属性     | 小驼峰式，以小写字符开头 | `firstName` 而不是 `first_name`         |

有关精确的命名规则，请参阅 [Cypher 手册 → 命名规则和建议](链接到 Cypher 手册中的命名规则和建议部分)。

# Cypher语句格式化与语法详解
以下是你提供的Cypher语句的标准格式化版本，后续将逐部分拆解语法含义：

```cypher
CREATE 
  // 创建标签为Person和Actor的节点（汤姆·汉克斯），并定义属性
  (:Person:Actor {name: 'Tom Hanks', born: 1956})
  // 创建ACTED_IN关系（扮演角色），并定义关系属性（角色列表）
  -[:ACTED_IN {roles: ['Forrest']}]->
  // 创建标签为Movie的节点（《阿甘正传》），并定义属性
  (:Movie {title: 'Forrest Gump', released: 1994})
  // 创建DIRECTED关系（执导），无额外属性
  <-[:DIRECTED]-
  // 创建标签为Person的节点（罗伯特·泽米吉斯），并定义属性
  (:Person {name: 'Robert Zemeckis', born: 1951})
```


## 一、核心语法框架：Cypher基本结构
Cypher是Neo4j图数据库的查询语言，核心是描述「节点」和「关系」的关联，上述语句通过`CREATE`命令一次性创建**3个节点**和**2个关系**，形成如下关联链：  
`Actor(Person)` -[ACTED_IN]-> `Movie` <-[DIRECTED]- `Person(Director)`


## 二、逐部分语法拆解
### 1. 关键字：`CREATE`
- **作用**：Cypher的「写操作核心关键字」，用于在图数据库中**新建节点、关系或节点+关系的组合**。  
- **注意**：`CREATE`是「幂等性无关」的命令——如果重复执行，会重复创建完全相同的节点和关系（即使属性、标签完全一致）；若需避免重复，需搭配`MERGE`（匹配或创建）使用。


### 2. 节点（Node）：图的基本单元
语句中包含3个节点，语法统一为 `(:标签列表 {属性键值对})`，以下分标签和属性详解：

#### （1）标签（Label）：`:Person:Actor` / `:Movie`
- **语法形式**：以冒号`:`开头，多个标签用冒号分隔（如`:Person:Actor`）。  
- **作用**：类似关系型数据库的「表名」，用于对节点进行分类，方便后续查询（如“查询所有Actor节点”）。  
  - 示例1：`:Person:Actor` → 该节点同时属于「Person（人）」和「Actor（演员）」两类，说明“汤姆·汉克斯是一个人，且职业是演员”。  
  - 示例2：`:Movie` → 该节点属于「Movie（电影）」类，说明“这是一个电影节点”。  
- **规则**：一个节点可拥有0个、1个或多个标签（0个标签的节点称为“无标签节点”，实际开发中较少用）。

#### （2）属性（Property）：`{name: 'Tom Hanks', born: 1956}`
- **语法形式**：用大括号`{}`包裹，内部是「键值对（Key-Value）」，键和值之间用冒号`:`分隔，多个键值对用逗号`,`分隔。  
- **作用**：存储节点的具体信息，类似关系型数据库的「字段+值」。  
- **各属性详解**：

| 节点类型       | 属性键（Key） | 属性值（Value）       | 数据类型   | 含义说明                     |
|----------------|---------------|-----------------------|------------|------------------------------|
| Person:Actor   | name          | 'Tom Hanks'           | 字符串（String） | 演员姓名：汤姆·汉克斯        |
| Person:Actor   | born          | 1956                  | 整数（Integer）  | 演员出生年份：1956年         |
| Movie          | title         | 'Forrest Gump'        | 字符串（String） | 电影标题：《阿甘正传》       |
| Movie          | released      | 1994                  | 整数（Integer）  | 电影上映年份：1994年         |
| Person（导演） | name          | 'Robert Zemeckis'     | 字符串（String） | 导演姓名：罗伯特·泽米吉斯    |
| Person（导演） | born          | 1951                  | 整数（Integer）  | 导演出生年份：1951年         |

- **数据类型规则**：Cypher支持多种数据类型，包括字符串（需用单引号`'`或双引号`"`包裹）、整数、浮点数、布尔值（`true`/`false`）、列表（如`['Forrest']`）、日期等。


### 3. 关系（Relationship）：连接节点的桥梁
语句中包含2个关系，语法为 `-[:关系类型 {关系属性}]->`（或`<--`表示反向），是图数据库的核心（区别于关系型数据库的关键）。

#### （1）关系方向：`->` / `<-`
- **作用**：表示关系的「起始节点」和「目标节点」，体现逻辑关联方向。  
  - `A-[:R]->B`：A是起始节点，B是目标节点，关系R从A指向B（如“演员→电影”表示“演员出演电影”）。  
  - `A<-[:R]-B`：B是起始节点，A是目标节点，关系R从B指向A（如“电影←导演”表示“导演执导电影”）。  
- **注意**：Cypher的关系是「有向的」，但查询时可忽略方向（用`-[:R]-`表示无向查询）。

#### （2）关系类型（Relationship Type）：`:ACTED_IN` / `:DIRECTED`
- **语法形式**：以冒号`:`开头，只能是**单个字符串**（不可多个类型，区别于节点标签）。  
- **作用**：定义关系的语义，说明两个节点之间的关联含义，类似“动词”。  
  - `:ACTED_IN`：表示“出演”关系，连接「演员节点」和「电影节点」（演员出演电影）。  
  - `:DIRECTED`：表示“执导”关系，连接「导演节点」和「电影节点」（导演执导电影）。  
- **规则**：一个关系必须有且仅有1个关系类型（不可无类型）。

#### （3）关系属性：`{roles: ['Forrest']}`
- **语法形式**：与节点属性一致，用`{}`包裹键值对；若关系无额外信息，可省略属性（如`:DIRECTED`）。  
- **作用**：存储关系的补充信息，说明“关系的具体细节”。  
  - 示例：`{roles: ['Forrest']}` → 表示“在`ACTED_IN`（出演）关系中，演员扮演的角色是`Forrest`（福雷斯，即阿甘）”。  
  - 数据类型：此处`roles`的值是「列表（List）」，用于存储多个角色（若演员在一部电影中扮演多个角色，可写为`['Role1', 'Role2']`）。


## 三、整体逻辑梳理
该语句的核心是在图数据库中构建「《阿甘正传》电影相关的人物关系网」，具体逻辑链如下：  
1. 创建「汤姆·汉克斯」节点：标签为`Person`（人）和`Actor`（演员），属性包含姓名和出生年份。  
2. 创建「《阿甘正传》」节点：标签为`Movie`（电影），属性包含标题和上映年份。  
3. 用`ACTED_IN`关系连接两者：表示“汤姆·汉克斯出演了《阿甘正传》”，并通过`roles`属性说明他扮演的角色是“Forrest”。  
4. 创建「罗伯特·泽米吉斯」节点：标签为`Person`（人）（隐含导演身份，若需明确可加`Director`标签），属性包含姓名和出生年份。  
5. 用`DIRECTED`关系连接「罗伯特·泽米吉斯」和「《阿甘正传》」：表示“罗伯特·泽米吉斯执导了《阿甘正传》”。

最终在图数据库中形成的结构，可直观体现“电影-演员-导演”的关联关系，这也是图数据库相比关系型数据库在“关联查询”上的核心优势。


# Neo4j 遍历/路径查询与模式（索引/约束）代码实例及语法详解
基于你提到的“Tom Hanks 电影关系”场景，以下将分**路径遍历查询**、**索引创建与使用**、**约束创建与验证**三部分，提供可直接执行的 Cypher 代码，并逐字段拆解语法含义，确保每个操作都能对应到实际业务场景（如查询演员参演电影、优化查询性能、保证数据唯一性）。


## 一、路径（Path）遍历与查询：找到 Tom Hanks 相关的关联数据
路径是 Neo4j 中“节点+关系”的组合，核心是通过 `MATCH` 匹配指定模式的关联链，解决“谁参演了什么电影”“某电影的导演是谁”等问题。以下结合你之前创建的「Tom Hanks-《阿甘正传》-Robert Zemeckis」数据，提供 4 类常用路径查询场景。


### 1. 基础路径查询：查找 Tom Hanks 参演的所有电影（长度为1的路径）
#### 需求
找到标签为 `Person:Actor`、姓名为 `Tom Hanks` 的节点，通过 `ACTED_IN` 关系关联的所有 `Movie` 节点，返回演员、关系（角色）和电影信息。

#### 代码
```cypher
// MATCH 匹配“演员-出演->电影”的路径模式，WHERE 过滤出 Tom Hanks
MATCH path = (actor:Person:Actor)-[acted:ACTED_IN]->(movie:Movie)
WHERE actor.name = 'Tom Hanks'
// RETURN 返回路径本身、演员姓名、扮演的角色、电影标题和上映年份
RETURN 
  path AS 完整路径,  // 路径对象（包含节点和关系）
  actor.name AS 演员姓名, 
  acted.roles AS 扮演角色,  // 关系的属性（角色列表）
  movie.title AS 电影标题, 
  movie.released AS 上映年份
```

#### 语法拆解
| 关键字/变量       | 含义与作用                                                                 |
|--------------------|----------------------------------------------------------------------------|
| `MATCH path = ...` | `MATCH` 是查询核心关键字，用于匹配图中的模式；`path` 是自定义变量，存储匹配到的路径（可任意命名，如 `p`）。 |
| `(actor:Person:Actor)` | 匹配标签为 `Person` 和 `Actor` 的节点，`actor` 是自定义变量（代表“演员节点”），后续可通过该变量访问节点属性（如 `actor.name`）。 |
| `-[:ACTED_IN]->`   | 匹配从演员节点指向电影节点、类型为 `ACTED_IN`（出演）的关系；`acted` 是关系的自定义变量，用于访问关系属性（如 `acted.roles`）。 |
| `WHERE actor.name = 'Tom Hanks'` | 过滤条件：仅保留“节点属性 `name` 为 `Tom Hanks`”的演员节点（避免匹配其他演员）。 |
| `RETURN ...`       | 定义查询结果的输出内容，`AS` 用于给结果列起别名（如 `actor.name AS 演员姓名`），方便阅读。 |

#### 执行结果
| 完整路径（可视化）               | 演员姓名   | 扮演角色   | 电影标题       | 上映年份 |
|----------------------------------|------------|------------|----------------|----------|
| Tom Hanks -[ACTED_IN]-> Forrest Gump | Tom Hanks  | ['Forrest'] | Forrest Gump   | 1994     |


### 2. 多关系路径查询：查找 Tom Hanks 参演电影的导演（长度为2的路径）
#### 需求
通过“演员-出演->电影-被执导<-导演”的路径，找到 Tom Hanks 参演电影的导演信息（路径长度=2：演员→电影←导演，包含 2 个关系）。

#### 代码
```cypher
MATCH 
  // 路径模式：演员-出演->电影<-执导-导演
  (actor:Person:Actor)-[:ACTED_IN]->(movie:Movie)<-[:DIRECTED]-(director:Person)
WHERE actor.name = 'Tom Hanks'
RETURN 
  actor.name AS 演员,
  movie.title AS 电影,
  director.name AS 导演,
  director.born AS 导演出生年份
```

#### 关键语法
- 路径长度：此路径包含 `ACTED_IN` 和 `DIRECTED` 两个关系，因此长度为 **2**（路径长度=关系数量）。
- 反向关系：`<-[:DIRECTED]-` 表示“从导演节点指向电影节点”的反向关系（导演→电影），通过 `<` 符号体现方向，匹配“导演执导电影”的逻辑。


### 3. 零长度路径查询：仅查询 Tom Hanks 节点本身
#### 需求
仅获取 Tom Hanks 节点的所有属性（路径长度=0：仅包含 1 个节点，无关系）。

#### 代码
```cypher
// 零长度路径：仅匹配单个节点，无关系
MATCH path = (actor:Person:Actor)
WHERE actor.name = 'Tom Hanks'
RETURN 
  path AS 零长度路径,  // 仅包含 Tom Hanks 节点
  actor.name AS 姓名,
  actor.born AS 出生年份
```

#### 核心说明
零长度路径的本质是“单个节点”，语法上只需匹配节点（无需关系部分），适用于仅查询节点属性的场景（如“查询 Tom Hanks 的出生年份”）。


### 4. 路径长度范围查询：查找 Tom Hanks 2步内关联的所有节点
#### 需求
通过 `*1..2` 定义路径长度范围（1到2步），查找 Tom Hanks 直接关联（1步：电影）和间接关联（2步：导演）的所有节点。

#### 代码
```cypher
// *1..2 表示路径长度为1或2（1个或2个关系）
MATCH path = (actor:Person:Actor)-[*1..2]-(relatedNode)
WHERE actor.name = 'Tom Hanks'
RETURN 
  path AS 关联路径,
  actor.name AS 起点（演员）,
  labels(relatedNode) AS 关联节点类型（标签）,  // labels() 函数获取节点的所有标签
  relatedNode.name AS 关联节点名称,  // 若为电影节点，此属性为 null（电影无 name 属性）
  relatedNode.title AS 关联节点标题  // 若为导演节点，此属性为 null（导演无 title 属性）
```

#### 关键语法
- `-[*1..2]-`：`*` 表示“任意关系类型”，`1..2` 表示路径长度范围（1到2步）；若省略上限（如 `*1..`），表示“1步及以上”；若写 `*`，表示“任意长度”（不推荐，易导致性能问题）。


## 二、模式（Schema）：索引与约束
Neo4j 是“模式可选”数据库，无需预先定义结构即可存储数据，但**索引**可提升查询性能，**约束**可保证数据一致性（如“演员姓名不能重复”“电影标题必须存在”）。以下基于 Tom Hanks 场景，提供 4 类常用模式操作。


### 1. 索引：优化“按姓名查询演员”的性能
#### 问题背景
若数据库中有 100 万演员节点，直接执行 `WHERE actor.name = 'Tom Hanks'` 会“全图扫描”所有演员节点，速度极慢；创建 `Person(name)` 索引后，查询会直接定位到 `name = 'Tom Hanks'` 的节点，性能提升 100+ 倍。

#### （1）创建单属性索引：为 Person 节点的 name 属性创建索引
##### 代码
```cypher
// CREATE INDEX 是创建索引的关键字，索引名称可自定义（如 person_name_idx）
CREATE INDEX person_name_idx 
FOR (p:Person)  // 为所有标签为 Person 的节点
ON (p.name)    // 基于 name 属性创建索引
```

##### 语法拆解
| 部分               | 含义与作用                                                                 |
|--------------------|----------------------------------------------------------------------------|
| `CREATE INDEX person_name_idx` | `CREATE INDEX` 触发索引创建，`person_name_idx` 是索引的自定义名称（便于后续管理，如删除索引）。 |
| `FOR (p:Person)`   | 指定索引作用的节点范围：仅对标签为 `Person` 的节点生效（不影响其他标签的节点，如 `Movie`）。 |
| `ON (p.name)`      | 指定索引基于的属性：仅对 `Person` 节点的 `name` 属性建立索引（查询 `p.name` 时会触发索引）。 |

#### （2）创建复合索引：为 Movie 节点的 title + released 属性创建索引
##### 需求
若需频繁执行“查询 1994 年上映的《阿甘正传》”（`WHERE movie.title = 'Forrest Gump' AND movie.released = 1994`），单属性索引效率不足，需创建复合索引。

##### 代码
```cypher
CREATE INDEX movie_title_released_idx
FOR (m:Movie)
ON (m.title, m.released)  // 基于 title 和 released 两个属性创建复合索引
```

#### （3）查看与删除索引
##### 查看所有索引
```cypher
// 列出数据库中所有索引的详细信息（名称、作用节点、属性等）
SHOW INDEXES
```

##### 删除索引（按名称）
```cypher
// DROP INDEX 用于删除索引，需指定索引名称
DROP INDEX person_name_idx
```


### 2. 约束：保证数据一致性
约束是“强制数据规则”，若插入/更新数据违反约束，Neo4j 会直接报错，避免脏数据（如“重复的演员姓名”“无标题的电影”）。以下是 3 类常用约束。

#### （1）唯一约束：确保 Person 节点的 name 属性唯一
##### 需求
避免创建两个“name = 'Tom Hanks'”的演员节点（即“一个演员只能有一条记录”）。

##### 代码
```cypher
// CREATE CONSTRAINT 是创建约束的关键字，约束名称可自定义
CREATE CONSTRAINT person_name_unique 
FOR (p:Person)  // 作用于标签为 Person 的节点
REQUIRE p.name IS UNIQUE  // 要求 p.name 属性的值必须唯一
```

##### 验证约束
- 尝试插入重复数据（会报错）：
  ```cypher
  // 错误：违反 person_name_unique 约束（name='Tom Hanks' 已存在）
  CREATE (:Person {name: 'Tom Hanks', born: 1990})
  ```
- 报错信息：`Node(xxx) already exists with label Person and property "name"=[Tom Hanks]`

#### （2）存在约束：确保 Movie 节点必须有 title 属性
##### 需求
避免创建“无 title 属性”的电影节点（即“每部电影必须有标题”）。

##### 代码
```cypher
CREATE CONSTRAINT movie_title_exists
FOR (m:Movie)
REQUIRE m.title IS NOT NULL  // 要求 m.title 属性必须存在（不能为 null）
```

##### 验证约束
- 尝试插入无 title 的电影（会报错）：
  ```cypher
  // 错误：违反 movie_title_exists 约束（title 为 null）
  CREATE (:Movie {released: 2024})
  ```
- 报错信息：`Node(xxx) with label Movie must have the property "title"`

#### （3）删除约束（按名称）
```cypher
// DROP CONSTRAINT 用于删除约束，需指定约束名称
DROP CONSTRAINT person_name_unique
```


## 三、总结：核心语法与使用场景对照表
| 操作类型       | 核心关键字       | 常用场景                                  | 关键语法示例                          |
|----------------|------------------|-------------------------------------------|---------------------------------------|
| 路径查询       | `MATCH`          | 查找演员参演的电影、电影的导演            | `(a:Actor)-[:ACTED_IN]->(m:Movie)`    |
| 索引创建       | `CREATE INDEX`   | 优化“按属性查询节点”的性能（如按姓名查演员） | `FOR (p:Person) ON (p.name)`          |
| 唯一约束       | `CREATE CONSTRAINT ... UNIQUE` | 确保属性值唯一（如演员姓名不重复）        | `REQUIRE p.name IS UNIQUE`            |
| 存在约束       | `CREATE CONSTRAINT ... NOT NULL` | 确保属性必须存在（如电影必须有标题）      | `REQUIRE m.title IS NOT NULL`         |

通过以上代码和解释，你可以直接在 Neo4j 浏览器（或其他客户端）中执行操作，快速掌握“路径查询”和“模式管理”的核心用法，同时对应到实际业务场景（如演员-电影关系分析、数据性能优化、数据一致性保障）。